"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_firebase_messaging_dist_esm_index_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/installations/dist/esm/index.esm2017.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteInstallations: function() { return /* binding */ deleteInstallations; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getInstallations: function() { return /* binding */ getInstallations; },\n/* harmony export */   getToken: function() { return /* binding */ getToken; },\n/* harmony export */   onIdChange: function() { return /* binding */ onIdChange; }\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(app-pages-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(app-pages-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(app-pages-browser)/./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/index.js\");\n\n\n\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.4\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const PENDING_TIMEOUT_MS = 10000;\nconst PACKAGE_VERSION = \"w:\".concat(version);\nconst INTERNAL_AUTH_VERSION = \"FIS_v2\";\nconst INSTALLATIONS_API_URL = \"https://firebaseinstallations.googleapis.com/v1\";\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\nconst SERVICE = \"installations\";\nconst SERVICE_NAME = \"Installations\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERROR_DESCRIPTION_MAP = {\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ ]: 'Missing App configuration value: \"{$valueName}\"',\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */ ]: \"Firebase Installation is not registered.\",\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */ ]: \"Firebase Installation not found.\",\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */ ]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */ ]: \"Could not process request. Application offline.\",\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */ ]: \"Can't delete installation while there is a pending registration request.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\n/** Returns true if error is a FirebaseError that is based on an error from the server. */ function isServerError(error) {\n    return error instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError && error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */ );\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getInstallationsEndpoint(param) {\n    let { projectId } = param;\n    return \"\".concat(INSTALLATIONS_API_URL, \"/projects/\").concat(projectId, \"/installations\");\n}\nfunction extractAuthTokenInfoFromResponse(response) {\n    return {\n        token: response.token,\n        requestStatus: 2 /* RequestStatus.COMPLETED */ ,\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n        creationTime: Date.now()\n    };\n}\nasync function getErrorFromResponse(requestName, response) {\n    const responseJson = await response.json();\n    const errorData = responseJson.error;\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */ , {\n        requestName,\n        serverCode: errorData.code,\n        serverMessage: errorData.message,\n        serverStatus: errorData.status\n    });\n}\nfunction getHeaders(param) {\n    let { apiKey } = param;\n    return new Headers({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        \"x-goog-api-key\": apiKey\n    });\n}\nfunction getHeadersWithAuth(appConfig, param) {\n    let { refreshToken } = param;\n    const headers = getHeaders(appConfig);\n    headers.append(\"Authorization\", getAuthorizationHeader(refreshToken));\n    return headers;\n}\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */ async function retryIfServerError(fn) {\n    const result = await fn();\n    if (result.status >= 500 && result.status < 600) {\n        // Internal Server Error. Retry request.\n        return fn();\n    }\n    return result;\n}\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\n    // This works because the server will never respond with fractions of a second.\n    return Number(responseExpiresIn.replace(\"s\", \"000\"));\n}\nfunction getAuthorizationHeader(refreshToken) {\n    return \"\".concat(INTERNAL_AUTH_VERSION, \" \").concat(refreshToken);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function createInstallationRequest(param, param1) {\n    let { appConfig, heartbeatServiceProvider } = param, { fid } = param1;\n    const endpoint = getInstallationsEndpoint(appConfig);\n    const headers = getHeaders(appConfig);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append(\"x-firebase-client\", heartbeatsHeader);\n        }\n    }\n    const body = {\n        fid,\n        authVersion: INTERNAL_AUTH_VERSION,\n        appId: appConfig.appId,\n        sdkVersion: PACKAGE_VERSION\n    };\n    const request = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const registeredInstallationEntry = {\n            fid: responseValue.fid || fid,\n            registrationStatus: 2 /* RequestStatus.COMPLETED */ ,\n            refreshToken: responseValue.refreshToken,\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n        };\n        return registeredInstallationEntry;\n    } else {\n        throw await getErrorFromResponse(\"Create Installation\", response);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Returns a promise that resolves after given time passes. */ function sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function bufferToBase64UrlSafe(array) {\n    const b64 = btoa(String.fromCharCode(...array));\n    return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nconst INVALID_FID = \"\";\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */ function generateFid() {\n    try {\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n        // bytes. our implementation generates a 17 byte array instead.\n        const fidByteArray = new Uint8Array(17);\n        const crypto = self.crypto || self.msCrypto;\n        crypto.getRandomValues(fidByteArray);\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\n        fidByteArray[0] = 112 + fidByteArray[0] % 16;\n        const fid = encode(fidByteArray);\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n    } catch (_a) {\n        // FID generation errored\n        return INVALID_FID;\n    }\n}\n/** Converts a FID Uint8Array to a base64 string representation. */ function encode(fidByteArray) {\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\n    // Remove the 23rd character that was added because of the extra 4 bits at the\n    // end of our 17 byte array, and the '=' padding.\n    return b64String.substr(0, 22);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Returns a string key that can be used to identify the app. */ function getKey(appConfig) {\n    return \"\".concat(appConfig.appName, \"!\").concat(appConfig.appId);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const fidChangeCallbacks = new Map();\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */ function fidChanged(appConfig, fid) {\n    const key = getKey(appConfig);\n    callFidChangeCallbacks(key, fid);\n    broadcastFidChange(key, fid);\n}\nfunction addCallback(appConfig, callback) {\n    // Open the broadcast channel if it's not already open,\n    // to be able to listen to change events from other tabs.\n    getBroadcastChannel();\n    const key = getKey(appConfig);\n    let callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        callbackSet = new Set();\n        fidChangeCallbacks.set(key, callbackSet);\n    }\n    callbackSet.add(callback);\n}\nfunction removeCallback(appConfig, callback) {\n    const key = getKey(appConfig);\n    const callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        return;\n    }\n    callbackSet.delete(callback);\n    if (callbackSet.size === 0) {\n        fidChangeCallbacks.delete(key);\n    }\n    // Close broadcast channel if there are no more callbacks.\n    closeBroadcastChannel();\n}\nfunction callFidChangeCallbacks(key, fid) {\n    const callbacks = fidChangeCallbacks.get(key);\n    if (!callbacks) {\n        return;\n    }\n    for (const callback of callbacks){\n        callback(fid);\n    }\n}\nfunction broadcastFidChange(key, fid) {\n    const channel = getBroadcastChannel();\n    if (channel) {\n        channel.postMessage({\n            key,\n            fid\n        });\n    }\n    closeBroadcastChannel();\n}\nlet broadcastChannel = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */ function getBroadcastChannel() {\n    if (!broadcastChannel && \"BroadcastChannel\" in self) {\n        broadcastChannel = new BroadcastChannel(\"[Firebase] FID Change\");\n        broadcastChannel.onmessage = (e)=>{\n            callFidChangeCallbacks(e.data.key, e.data.fid);\n        };\n    }\n    return broadcastChannel;\n}\nfunction closeBroadcastChannel() {\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n        broadcastChannel.close();\n        broadcastChannel = null;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DATABASE_NAME = \"firebase-installations-database\";\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = \"firebase-installations-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DATABASE_NAME, DATABASE_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        db.createObjectStore(OBJECT_STORE_NAME);\n                }\n            }\n        });\n    }\n    return dbPromise;\n}\n/** Assigns or overwrites the record for the given key with the given value. */ async function set(appConfig, value) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = await objectStore.get(key);\n    await objectStore.put(value, key);\n    await tx.done;\n    if (!oldValue || oldValue.fid !== value.fid) {\n        fidChanged(appConfig, value.fid);\n    }\n    return value;\n}\n/** Removes record(s) from the objectStore that match the given key. */ async function remove(appConfig) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n    await tx.done;\n}\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */ async function update(appConfig, updateFn) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = await store.get(key);\n    const newValue = updateFn(oldValue);\n    if (newValue === undefined) {\n        await store.delete(key);\n    } else {\n        await store.put(newValue, key);\n    }\n    await tx.done;\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n        fidChanged(appConfig, newValue.fid);\n    }\n    return newValue;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */ async function getInstallationEntry(installations) {\n    let registrationPromise;\n    const installationEntry = await update(installations.appConfig, (oldEntry)=>{\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\n        registrationPromise = entryWithPromise.registrationPromise;\n        return entryWithPromise.installationEntry;\n    });\n    if (installationEntry.fid === INVALID_FID) {\n        // FID generation failed. Waiting for the FID from the server.\n        return {\n            installationEntry: await registrationPromise\n        };\n    }\n    return {\n        installationEntry,\n        registrationPromise\n    };\n}\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */ function updateOrCreateInstallationEntry(oldEntry) {\n    const entry = oldEntry || {\n        fid: generateFid(),\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n    };\n    return clearTimedOutRequest(entry);\n}\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */ function triggerRegistrationIfNecessary(installations, installationEntry) {\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        if (!navigator.onLine) {\n            // Registration required but app is offline.\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ ));\n            return {\n                installationEntry,\n                registrationPromise: registrationPromiseWithError\n            };\n        }\n        // Try registering. Change status to IN_PROGRESS.\n        const inProgressEntry = {\n            fid: installationEntry.fid,\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */ ,\n            registrationTime: Date.now()\n        };\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\n        return {\n            installationEntry: inProgressEntry,\n            registrationPromise\n        };\n    } else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n        return {\n            installationEntry,\n            registrationPromise: waitUntilFidRegistration(installations)\n        };\n    } else {\n        return {\n            installationEntry\n        };\n    }\n}\n/** This will be executed only once for each new Firebase Installation. */ async function registerInstallation(installations, installationEntry) {\n    try {\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\n        return set(installations.appConfig, registeredInstallationEntry);\n    } catch (e) {\n        if (isServerError(e) && e.customData.serverCode === 409) {\n            // Server returned a \"FID can not be used\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        } else {\n            // Registration failed. Set FID as not registered.\n            await set(installations.appConfig, {\n                fid: installationEntry.fid,\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n            });\n        }\n        throw e;\n    }\n}\n/** Call if FID registration is pending in another request. */ async function waitUntilFidRegistration(installations) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateInstallationRequest(installations.appConfig);\n    while(entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ){\n        // createInstallation request still in progress.\n        await sleep(100);\n        entry = await updateInstallationRequest(installations.appConfig);\n    }\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        // The request timed out or failed in a different call. Try again.\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\n        if (registrationPromise) {\n            return registrationPromise;\n        } else {\n            // if there is no registrationPromise, entry is registered.\n            return installationEntry;\n        }\n    }\n    return entry;\n}\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */ function updateInstallationRequest(appConfig) {\n    return update(appConfig, (oldEntry)=>{\n        if (!oldEntry) {\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */ );\n        }\n        return clearTimedOutRequest(oldEntry);\n    });\n}\nfunction clearTimedOutRequest(entry) {\n    if (hasInstallationRequestTimedOut(entry)) {\n        return {\n            fid: entry.fid,\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n        };\n    }\n    return entry;\n}\nfunction hasInstallationRequestTimedOut(installationEntry) {\n    return installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */  && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function generateAuthTokenRequest(param, installationEntry) {\n    let { appConfig, heartbeatServiceProvider } = param;\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append(\"x-firebase-client\", heartbeatsHeader);\n        }\n    }\n    const body = {\n        installation: {\n            sdkVersion: PACKAGE_VERSION,\n            appId: appConfig.appId\n        }\n    };\n    const request = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\n        return completedAuthToken;\n    } else {\n        throw await getErrorFromResponse(\"Generate Auth Token\", response);\n    }\n}\nfunction getGenerateAuthTokenEndpoint(appConfig, param) {\n    let { fid } = param;\n    return \"\".concat(getInstallationsEndpoint(appConfig), \"/\").concat(fid, \"/authTokens:generate\");\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */ async function refreshAuthToken(installations) {\n    let forceRefresh = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let tokenPromise;\n    const entry = await update(installations.appConfig, (oldEntry)=>{\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */ );\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n            // There is a valid token in the DB.\n            return oldEntry;\n        } else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n            // There already is a token request in progress.\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\n            return oldEntry;\n        } else {\n            // No token or token expired.\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ );\n            }\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\n            return inProgressEntry;\n        }\n    });\n    const authToken = tokenPromise ? await tokenPromise : entry.authToken;\n    return authToken;\n}\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */ async function waitUntilAuthTokenRequest(installations, forceRefresh) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateAuthTokenRequest(installations.appConfig);\n    while(entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ ){\n        // generateAuthToken still in progress.\n        await sleep(100);\n        entry = await updateAuthTokenRequest(installations.appConfig);\n    }\n    const authToken = entry.authToken;\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        // The request timed out or failed in a different call. Try again.\n        return refreshAuthToken(installations, forceRefresh);\n    } else {\n        return authToken;\n    }\n}\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */ function updateAuthTokenRequest(appConfig) {\n    return update(appConfig, (oldEntry)=>{\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */ );\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n            return Object.assign(Object.assign({}, oldEntry), {\n                authToken: {\n                    requestStatus: 0 /* RequestStatus.NOT_STARTED */ \n                }\n            });\n        }\n        return oldEntry;\n    });\n}\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\n    try {\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), {\n            authToken\n        });\n        await set(installations.appConfig, updatedInstallationEntry);\n        return authToken;\n    } catch (e) {\n        if (isServerError(e) && (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        } else {\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), {\n                authToken: {\n                    requestStatus: 0 /* RequestStatus.NOT_STARTED */ \n                }\n            });\n            await set(installations.appConfig, updatedInstallationEntry);\n        }\n        throw e;\n    }\n}\nfunction isEntryRegistered(installationEntry) {\n    return installationEntry !== undefined && installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */ ;\n}\nfunction isAuthTokenValid(authToken) {\n    return authToken.requestStatus === 2 /* RequestStatus.COMPLETED */  && !isAuthTokenExpired(authToken);\n}\nfunction isAuthTokenExpired(authToken) {\n    const now = Date.now();\n    return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;\n}\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */ function makeAuthTokenRequestInProgressEntry(oldEntry) {\n    const inProgressAuthToken = {\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */ ,\n        requestTime: Date.now()\n    };\n    return Object.assign(Object.assign({}, oldEntry), {\n        authToken: inProgressAuthToken\n    });\n}\nfunction hasAuthTokenRequestTimedOut(authToken) {\n    return authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */  && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */ async function getId(installations) {\n    const installationsImpl = installations;\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\n    if (registrationPromise) {\n        registrationPromise.catch(console.error);\n    } else {\n        // If the installation is already registered, update the authentication\n        // token if needed.\n        refreshAuthToken(installationsImpl).catch(console.error);\n    }\n    return installationEntry.fid;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */ async function getToken(installations) {\n    let forceRefresh = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const installationsImpl = installations;\n    await completeInstallationRegistration(installationsImpl);\n    // At this point we either have a Registered Installation in the DB, or we've\n    // already thrown an error.\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\n    return authToken.token;\n}\nasync function completeInstallationRegistration(installations) {\n    const { registrationPromise } = await getInstallationEntry(installations);\n    if (registrationPromise) {\n        // A createInstallation request is in progress. Wait until it finishes.\n        await registrationPromise;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function deleteInstallationRequest(appConfig, installationEntry) {\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    const request = {\n        method: \"DELETE\",\n        headers\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (!response.ok) {\n        throw await getErrorFromResponse(\"Delete Installation\", response);\n    }\n}\nfunction getDeleteEndpoint(appConfig, param) {\n    let { fid } = param;\n    return \"\".concat(getInstallationsEndpoint(appConfig), \"/\").concat(fid);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */ async function deleteInstallations(installations) {\n    const { appConfig } = installations;\n    const entry = await update(appConfig, (oldEntry)=>{\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n            // Delete the unregistered entry without sending a deleteInstallation request.\n            return undefined;\n        }\n        return oldEntry;\n    });\n    if (entry) {\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n            // Can't delete while trying to register.\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */ );\n        } else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */ ) {\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ );\n            } else {\n                await deleteInstallationRequest(appConfig, entry);\n                await remove(appConfig);\n            }\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */ function onIdChange(installations, callback) {\n    const { appConfig } = installations;\n    addCallback(appConfig, callback);\n    return ()=>{\n        removeCallback(appConfig, callback);\n    };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */ function getInstallations() {\n    let app = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const installationsImpl = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"installations\").getImmediate();\n    return installationsImpl;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function extractAppConfig(app) {\n    if (!app || !app.options) {\n        throw getMissingValueError(\"App Configuration\");\n    }\n    if (!app.name) {\n        throw getMissingValueError(\"App Name\");\n    }\n    // Required app config keys\n    const configKeys = [\n        \"projectId\",\n        \"apiKey\",\n        \"appId\"\n    ];\n    for (const keyName of configKeys){\n        if (!app.options[keyName]) {\n            throw getMissingValueError(keyName);\n        }\n    }\n    return {\n        appName: app.name,\n        projectId: app.options.projectId,\n        apiKey: app.options.apiKey,\n        appId: app.options.appId\n    };\n}\nfunction getMissingValueError(valueName) {\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ , {\n        valueName\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const INSTALLATIONS_NAME = \"installations\";\nconst INSTALLATIONS_NAME_INTERNAL = \"installations-internal\";\nconst publicFactory = (container)=>{\n    const app = container.getProvider(\"app\").getImmediate();\n    // Throws if app isn't configured properly.\n    const appConfig = extractAppConfig(app);\n    const heartbeatServiceProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"heartbeat\");\n    const installationsImpl = {\n        app,\n        appConfig,\n        heartbeatServiceProvider,\n        _delete: ()=>Promise.resolve()\n    };\n    return installationsImpl;\n};\nconst internalFactory = (container)=>{\n    const app = container.getProvider(\"app\").getImmediate();\n    // Internal FIS instance relies on public FIS instance.\n    const installations = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, INSTALLATIONS_NAME).getImmediate();\n    const installationsInternal = {\n        getId: ()=>getId(installations),\n        getToken: (forceRefresh)=>getToken(installations, forceRefresh)\n    };\n    return installationsInternal;\n};\nfunction registerInstallations() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n}\n/**\r\n * Firebase Installations\r\n *\r\n * @packageDocumentation\r\n */ registerInstallations();\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"esm2017\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRjtBQUMxQztBQUNhO0FBQ2hDO0FBRTdCLE1BQU1RLE9BQU87QUFDYixNQUFNQyxVQUFVO0FBRWhCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxrQkFBa0IsS0FBYSxPQUFSRjtBQUM3QixNQUFNRyx3QkFBd0I7QUFDOUIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLDBCQUEwQixLQUFLLEtBQUssTUFBTSxXQUFXO0FBQzNELE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsZUFBZTtBQUVyQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyx3QkFBd0I7SUFDMUIsQ0FBQyw0QkFBNEIsdUNBQXVDLElBQUcsRUFBRTtJQUN6RSxDQUFDLGlCQUFpQiw0QkFBNEIsSUFBRyxFQUFFO0lBQ25ELENBQUMseUJBQXlCLG9DQUFvQyxJQUFHLEVBQUU7SUFDbkUsQ0FBQyxpQkFBaUIsNEJBQTRCLElBQUcsRUFBRTtJQUNuRCxDQUFDLGNBQWMseUJBQXlCLElBQUcsRUFBRTtJQUM3QyxDQUFDLDhCQUE4Qix5Q0FBeUMsSUFBRyxFQUFFO0FBQ2pGO0FBQ0EsTUFBTUMsZ0JBQWdCLElBQUliLHdEQUFZQSxDQUFDVSxTQUFTQyxjQUFjQztBQUM5RCx3RkFBd0YsR0FDeEYsU0FBU0UsY0FBY0MsS0FBSztJQUN4QixPQUFRQSxpQkFBaUJkLHlEQUFhQSxJQUNsQ2MsTUFBTUMsSUFBSSxDQUFDQyxRQUFRLENBQUMsaUJBQWlCLDRCQUE0QjtBQUN6RTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELFNBQVNDLHlCQUF5QixLQUFhO1FBQWIsRUFBRUMsU0FBUyxFQUFFLEdBQWI7SUFDOUIsT0FBTyxHQUFxQ0EsT0FBbENYLHVCQUFzQixj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SUFDQSxPQUFPb0g7QUFDWDtBQUNBLE1BQU11QixrQkFBa0IsQ0FBQ0g7SUFDckIsTUFBTVYsTUFBTVUsVUFBVUMsV0FBVyxDQUFDLE9BQU85SixZQUFZO0lBQ3JELHVEQUF1RDtJQUN2RCxNQUFNK0YsZ0JBQWdCakssMkRBQVlBLENBQUNxTixLQUFLTyxvQkFBb0IxSixZQUFZO0lBQ3hFLE1BQU1pSyx3QkFBd0I7UUFDMUJ6QixPQUFPLElBQU1BLE1BQU16QztRQUNuQjZDLFVBQVUsQ0FBQ3BCLGVBQWlCb0IsU0FBUzdDLGVBQWV5QjtJQUN4RDtJQUNBLE9BQU95QztBQUNYO0FBQ0EsU0FBU0M7SUFDTGxPLGlFQUFrQkEsQ0FBQyxJQUFJRSwwREFBU0EsQ0FBQ3dOLG9CQUFvQkUsZUFBZSxTQUFTLHdCQUF3QjtJQUNyRzVOLGlFQUFrQkEsQ0FBQyxJQUFJRSwwREFBU0EsQ0FBQ3lOLDZCQUE2QkssaUJBQWlCLFVBQVUseUJBQXlCO0FBQ3RIO0FBRUE7Ozs7Q0FJQyxHQUNERTtBQUNBak8sOERBQWVBLENBQUNLLE1BQU1DO0FBQ3RCLCtGQUErRjtBQUMvRk4sOERBQWVBLENBQUNLLE1BQU1DLFNBQVM7QUFFK0MsQ0FDOUUseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzM3NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjYuNFwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQRU5ESU5HX1RJTUVPVVRfTVMgPSAxMDAwMDtcclxuY29uc3QgUEFDS0FHRV9WRVJTSU9OID0gYHc6JHt2ZXJzaW9ufWA7XHJcbmNvbnN0IElOVEVSTkFMX0FVVEhfVkVSU0lPTiA9ICdGSVNfdjInO1xyXG5jb25zdCBJTlNUQUxMQVRJT05TX0FQSV9VUkwgPSAnaHR0cHM6Ly9maXJlYmFzZWluc3RhbGxhdGlvbnMuZ29vZ2xlYXBpcy5jb20vdjEnO1xyXG5jb25zdCBUT0tFTl9FWFBJUkFUSU9OX0JVRkZFUiA9IDYwICogNjAgKiAxMDAwOyAvLyBPbmUgaG91clxyXG5jb25zdCBTRVJWSUNFID0gJ2luc3RhbGxhdGlvbnMnO1xyXG5jb25zdCBTRVJWSUNFX05BTUUgPSAnSW5zdGFsbGF0aW9ucyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SX0RFU0NSSVBUSU9OX01BUCA9IHtcclxuICAgIFtcIm1pc3NpbmctYXBwLWNvbmZpZy12YWx1ZXNcIiAvKiBFcnJvckNvZGUuTUlTU0lOR19BUFBfQ09ORklHX1ZBTFVFUyAqL106ICdNaXNzaW5nIEFwcCBjb25maWd1cmF0aW9uIHZhbHVlOiBcInskdmFsdWVOYW1lfVwiJyxcclxuICAgIFtcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovXTogJ0ZpcmViYXNlIEluc3RhbGxhdGlvbiBpcyBub3QgcmVnaXN0ZXJlZC4nLFxyXG4gICAgW1wiaW5zdGFsbGF0aW9uLW5vdC1mb3VuZFwiIC8qIEVycm9yQ29kZS5JTlNUQUxMQVRJT05fTk9UX0ZPVU5EICovXTogJ0ZpcmViYXNlIEluc3RhbGxhdGlvbiBub3QgZm91bmQuJyxcclxuICAgIFtcInJlcXVlc3QtZmFpbGVkXCIgLyogRXJyb3JDb2RlLlJFUVVFU1RfRkFJTEVEICovXTogJ3skcmVxdWVzdE5hbWV9IHJlcXVlc3QgZmFpbGVkIHdpdGggZXJyb3IgXCJ7JHNlcnZlckNvZGV9IHskc2VydmVyU3RhdHVzfTogeyRzZXJ2ZXJNZXNzYWdlfVwiJyxcclxuICAgIFtcImFwcC1vZmZsaW5lXCIgLyogRXJyb3JDb2RlLkFQUF9PRkZMSU5FICovXTogJ0NvdWxkIG5vdCBwcm9jZXNzIHJlcXVlc3QuIEFwcGxpY2F0aW9uIG9mZmxpbmUuJyxcclxuICAgIFtcImRlbGV0ZS1wZW5kaW5nLXJlZ2lzdHJhdGlvblwiIC8qIEVycm9yQ29kZS5ERUxFVEVfUEVORElOR19SRUdJU1RSQVRJT04gKi9dOiBcIkNhbid0IGRlbGV0ZSBpbnN0YWxsYXRpb24gd2hpbGUgdGhlcmUgaXMgYSBwZW5kaW5nIHJlZ2lzdHJhdGlvbiByZXF1ZXN0LlwiXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KFNFUlZJQ0UsIFNFUlZJQ0VfTkFNRSwgRVJST1JfREVTQ1JJUFRJT05fTUFQKTtcclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBlcnJvciBpcyBhIEZpcmViYXNlRXJyb3IgdGhhdCBpcyBiYXNlZCBvbiBhbiBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIuICovXHJcbmZ1bmN0aW9uIGlzU2VydmVyRXJyb3IoZXJyb3IpIHtcclxuICAgIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmXHJcbiAgICAgICAgZXJyb3IuY29kZS5pbmNsdWRlcyhcInJlcXVlc3QtZmFpbGVkXCIgLyogRXJyb3JDb2RlLlJFUVVFU1RfRkFJTEVEICovKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50KHsgcHJvamVjdElkIH0pIHtcclxuICAgIHJldHVybiBgJHtJTlNUQUxMQVRJT05TX0FQSV9VUkx9L3Byb2plY3RzLyR7cHJvamVjdElkfS9pbnN0YWxsYXRpb25zYDtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0QXV0aFRva2VuSW5mb0Zyb21SZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0b2tlbjogcmVzcG9uc2UudG9rZW4sXHJcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLyxcclxuICAgICAgICBleHBpcmVzSW46IGdldEV4cGlyZXNJbkZyb21SZXNwb25zZUV4cGlyZXNJbihyZXNwb25zZS5leHBpcmVzSW4pLFxyXG4gICAgICAgIGNyZWF0aW9uVGltZTogRGF0ZS5ub3coKVxyXG4gICAgfTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBnZXRFcnJvckZyb21SZXNwb25zZShyZXF1ZXN0TmFtZSwgcmVzcG9uc2UpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnN0IGVycm9yRGF0YSA9IHJlc3BvbnNlSnNvbi5lcnJvcjtcclxuICAgIHJldHVybiBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInJlcXVlc3QtZmFpbGVkXCIgLyogRXJyb3JDb2RlLlJFUVVFU1RfRkFJTEVEICovLCB7XHJcbiAgICAgICAgcmVxdWVzdE5hbWUsXHJcbiAgICAgICAgc2VydmVyQ29kZTogZXJyb3JEYXRhLmNvZGUsXHJcbiAgICAgICAgc2VydmVyTWVzc2FnZTogZXJyb3JEYXRhLm1lc3NhZ2UsXHJcbiAgICAgICAgc2VydmVyU3RhdHVzOiBlcnJvckRhdGEuc3RhdHVzXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIZWFkZXJzKHsgYXBpS2V5IH0pIHtcclxuICAgIHJldHVybiBuZXcgSGVhZGVycyh7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAneC1nb29nLWFwaS1rZXknOiBhcGlLZXlcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhlYWRlcnNXaXRoQXV0aChhcHBDb25maWcsIHsgcmVmcmVzaFRva2VuIH0pIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRIZWFkZXJzKGFwcENvbmZpZyk7XHJcbiAgICBoZWFkZXJzLmFwcGVuZCgnQXV0aG9yaXphdGlvbicsIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVmcmVzaFRva2VuKSk7XHJcbiAgICByZXR1cm4gaGVhZGVycztcclxufVxyXG4vKipcclxuICogQ2FsbHMgdGhlIHBhc3NlZCBpbiBmZXRjaCB3cmFwcGVyIGFuZCByZXR1cm5zIHRoZSByZXNwb25zZS5cclxuICogSWYgdGhlIHJldHVybmVkIHJlc3BvbnNlIGhhcyBhIHN0YXR1cyBvZiA1eHgsIHJlLXJ1bnMgdGhlIGZ1bmN0aW9uIG9uY2UgYW5kXHJcbiAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmV0cnlJZlNlcnZlckVycm9yKGZuKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpO1xyXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPj0gNTAwICYmIHJlc3VsdC5zdGF0dXMgPCA2MDApIHtcclxuICAgICAgICAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3IuIFJldHJ5IHJlcXVlc3QuXHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldEV4cGlyZXNJbkZyb21SZXNwb25zZUV4cGlyZXNJbihyZXNwb25zZUV4cGlyZXNJbikge1xyXG4gICAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBzZXJ2ZXIgd2lsbCBuZXZlciByZXNwb25kIHdpdGggZnJhY3Rpb25zIG9mIGEgc2Vjb25kLlxyXG4gICAgcmV0dXJuIE51bWJlcihyZXNwb25zZUV4cGlyZXNJbi5yZXBsYWNlKCdzJywgJzAwMCcpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBdXRob3JpemF0aW9uSGVhZGVyKHJlZnJlc2hUb2tlbikge1xyXG4gICAgcmV0dXJuIGAke0lOVEVSTkFMX0FVVEhfVkVSU0lPTn0gJHtyZWZyZXNoVG9rZW59YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KHsgYXBwQ29uZmlnLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgfSwgeyBmaWQgfSkge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSBnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRIZWFkZXJzKGFwcENvbmZpZyk7XHJcbiAgICAvLyBJZiBoZWFydGJlYXQgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgaGVhcnRiZWF0IHN0cmluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0U2VydmljZSA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGlmIChoZWFydGJlYXRTZXJ2aWNlKSB7XHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0IGhlYXJ0YmVhdFNlcnZpY2UuZ2V0SGVhcnRiZWF0c0hlYWRlcigpO1xyXG4gICAgICAgIGlmIChoZWFydGJlYXRzSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCd4LWZpcmViYXNlLWNsaWVudCcsIGhlYXJ0YmVhdHNIZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGJvZHkgPSB7XHJcbiAgICAgICAgZmlkLFxyXG4gICAgICAgIGF1dGhWZXJzaW9uOiBJTlRFUk5BTF9BVVRIX1ZFUlNJT04sXHJcbiAgICAgICAgYXBwSWQ6IGFwcENvbmZpZy5hcHBJZCxcclxuICAgICAgICBzZGtWZXJzaW9uOiBQQUNLQUdFX1ZFUlNJT05cclxuICAgIH07XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5SWZTZXJ2ZXJFcnJvcigoKSA9PiBmZXRjaChlbmRwb2ludCwgcmVxdWVzdCkpO1xyXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zdCByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnkgPSB7XHJcbiAgICAgICAgICAgIGZpZDogcmVzcG9uc2VWYWx1ZS5maWQgfHwgZmlkLFxyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDIgLyogUmVxdWVzdFN0YXR1cy5DT01QTEVURUQgKi8sXHJcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogcmVzcG9uc2VWYWx1ZS5yZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgICAgIGF1dGhUb2tlbjogZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZS5hdXRoVG9rZW4pXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEluc3RhbGxhdGlvbkVudHJ5O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgYXdhaXQgZ2V0RXJyb3JGcm9tUmVzcG9uc2UoJ0NyZWF0ZSBJbnN0YWxsYXRpb24nLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgZ2l2ZW4gdGltZSBwYXNzZXMuICovXHJcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBidWZmZXJUb0Jhc2U2NFVybFNhZmUoYXJyYXkpIHtcclxuICAgIGNvbnN0IGI2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hcnJheSkpO1xyXG4gICAgcmV0dXJuIGI2NC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBWQUxJRF9GSURfUEFUVEVSTiA9IC9eW2NkZWZdW1xcdy1dezIxfSQvO1xyXG5jb25zdCBJTlZBTElEX0ZJRCA9ICcnO1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbmV3IEZJRCB1c2luZyByYW5kb20gdmFsdWVzIGZyb20gV2ViIENyeXB0byBBUEkuXHJcbiAqIFJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIEZJRCBnZW5lcmF0aW9uIGZhaWxzIGZvciBhbnkgcmVhc29uLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVGaWQoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEEgdmFsaWQgRklEIGhhcyBleGFjdGx5IDIyIGJhc2U2NCBjaGFyYWN0ZXJzLCB3aGljaCBpcyAxMzIgYml0cywgb3IgMTYuNVxyXG4gICAgICAgIC8vIGJ5dGVzLiBvdXIgaW1wbGVtZW50YXRpb24gZ2VuZXJhdGVzIGEgMTcgYnl0ZSBhcnJheSBpbnN0ZWFkLlxyXG4gICAgICAgIGNvbnN0IGZpZEJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KDE3KTtcclxuICAgICAgICBjb25zdCBjcnlwdG8gPSBzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvO1xyXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZmlkQnl0ZUFycmF5KTtcclxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBmaXJzdCA0IHJhbmRvbSBiaXRzIHdpdGggdGhlIGNvbnN0YW50IEZJRCBoZWFkZXIgb2YgMGIwMTExLlxyXG4gICAgICAgIGZpZEJ5dGVBcnJheVswXSA9IDBiMDExMTAwMDAgKyAoZmlkQnl0ZUFycmF5WzBdICUgMGIwMDAxMDAwMCk7XHJcbiAgICAgICAgY29uc3QgZmlkID0gZW5jb2RlKGZpZEJ5dGVBcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIFZBTElEX0ZJRF9QQVRURVJOLnRlc3QoZmlkKSA/IGZpZCA6IElOVkFMSURfRklEO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgLy8gRklEIGdlbmVyYXRpb24gZXJyb3JlZFxyXG4gICAgICAgIHJldHVybiBJTlZBTElEX0ZJRDtcclxuICAgIH1cclxufVxyXG4vKiogQ29udmVydHMgYSBGSUQgVWludDhBcnJheSB0byBhIGJhc2U2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICovXHJcbmZ1bmN0aW9uIGVuY29kZShmaWRCeXRlQXJyYXkpIHtcclxuICAgIGNvbnN0IGI2NFN0cmluZyA9IGJ1ZmZlclRvQmFzZTY0VXJsU2FmZShmaWRCeXRlQXJyYXkpO1xyXG4gICAgLy8gUmVtb3ZlIHRoZSAyM3JkIGNoYXJhY3RlciB0aGF0IHdhcyBhZGRlZCBiZWNhdXNlIG9mIHRoZSBleHRyYSA0IGJpdHMgYXQgdGhlXHJcbiAgICAvLyBlbmQgb2Ygb3VyIDE3IGJ5dGUgYXJyYXksIGFuZCB0aGUgJz0nIHBhZGRpbmcuXHJcbiAgICByZXR1cm4gYjY0U3RyaW5nLnN1YnN0cigwLCAyMik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFJldHVybnMgYSBzdHJpbmcga2V5IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGFwcC4gKi9cclxuZnVuY3Rpb24gZ2V0S2V5KGFwcENvbmZpZykge1xyXG4gICAgcmV0dXJuIGAke2FwcENvbmZpZy5hcHBOYW1lfSEke2FwcENvbmZpZy5hcHBJZH1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGZpZENoYW5nZUNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIENhbGxzIHRoZSBvbklkQ2hhbmdlIGNhbGxiYWNrcyB3aXRoIHRoZSBuZXcgRklEIHZhbHVlLCBhbmQgYnJvYWRjYXN0cyB0aGVcclxuICogY2hhbmdlIHRvIG90aGVyIHRhYnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWRDaGFuZ2VkKGFwcENvbmZpZywgZmlkKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGNhbGxGaWRDaGFuZ2VDYWxsYmFja3Moa2V5LCBmaWQpO1xyXG4gICAgYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKTtcclxufVxyXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhhcHBDb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICAvLyBPcGVuIHRoZSBicm9hZGNhc3QgY2hhbm5lbCBpZiBpdCdzIG5vdCBhbHJlYWR5IG9wZW4sXHJcbiAgICAvLyB0byBiZSBhYmxlIHRvIGxpc3RlbiB0byBjaGFuZ2UgZXZlbnRzIGZyb20gb3RoZXIgdGFicy5cclxuICAgIGdldEJyb2FkY2FzdENoYW5uZWwoKTtcclxuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xyXG4gICAgbGV0IGNhbGxiYWNrU2V0ID0gZmlkQ2hhbmdlQ2FsbGJhY2tzLmdldChrZXkpO1xyXG4gICAgaWYgKCFjYWxsYmFja1NldCkge1xyXG4gICAgICAgIGNhbGxiYWNrU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZpZENoYW5nZUNhbGxiYWNrcy5zZXQoa2V5LCBjYWxsYmFja1NldCk7XHJcbiAgICB9XHJcbiAgICBjYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKGFwcENvbmZpZywgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xyXG4gICAgY29uc3QgY2FsbGJhY2tTZXQgPSBmaWRDaGFuZ2VDYWxsYmFja3MuZ2V0KGtleSk7XHJcbiAgICBpZiAoIWNhbGxiYWNrU2V0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2FsbGJhY2tTZXQuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgIGlmIChjYWxsYmFja1NldC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgZmlkQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xvc2UgYnJvYWRjYXN0IGNoYW5uZWwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2FsbGJhY2tzLlxyXG4gICAgY2xvc2VCcm9hZGNhc3RDaGFubmVsKCk7XHJcbn1cclxuZnVuY3Rpb24gY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhrZXksIGZpZCkge1xyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gZmlkQ2hhbmdlQ2FsbGJhY2tzLmdldChrZXkpO1xyXG4gICAgaWYgKCFjYWxsYmFja3MpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xyXG4gICAgICAgIGNhbGxiYWNrKGZpZCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKSB7XHJcbiAgICBjb25zdCBjaGFubmVsID0gZ2V0QnJvYWRjYXN0Q2hhbm5lbCgpO1xyXG4gICAgaWYgKGNoYW5uZWwpIHtcclxuICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHsga2V5LCBmaWQgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZUJyb2FkY2FzdENoYW5uZWwoKTtcclxufVxyXG5sZXQgYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XHJcbi8qKiBPcGVucyBhbmQgcmV0dXJucyBhIEJyb2FkY2FzdENoYW5uZWwgaWYgaXQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLiAqL1xyXG5mdW5jdGlvbiBnZXRCcm9hZGNhc3RDaGFubmVsKCkge1xyXG4gICAgaWYgKCFicm9hZGNhc3RDaGFubmVsICYmICdCcm9hZGNhc3RDaGFubmVsJyBpbiBzZWxmKSB7XHJcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKCdbRmlyZWJhc2VdIEZJRCBDaGFuZ2UnKTtcclxuICAgICAgICBicm9hZGNhc3RDaGFubmVsLm9ubWVzc2FnZSA9IGUgPT4ge1xyXG4gICAgICAgICAgICBjYWxsRmlkQ2hhbmdlQ2FsbGJhY2tzKGUuZGF0YS5rZXksIGUuZGF0YS5maWQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnJvYWRjYXN0Q2hhbm5lbDtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUJyb2FkY2FzdENoYW5uZWwoKSB7XHJcbiAgICBpZiAoZmlkQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDAgJiYgYnJvYWRjYXN0Q2hhbm5lbCkge1xyXG4gICAgICAgIGJyb2FkY2FzdENoYW5uZWwuY2xvc2UoKTtcclxuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbnVsbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQVRBQkFTRV9OQU1FID0gJ2ZpcmViYXNlLWluc3RhbGxhdGlvbnMtZGF0YWJhc2UnO1xyXG5jb25zdCBEQVRBQkFTRV9WRVJTSU9OID0gMTtcclxuY29uc3QgT0JKRUNUX1NUT1JFX05BTUUgPSAnZmlyZWJhc2UtaW5zdGFsbGF0aW9ucy1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQVRBQkFTRV9OQU1FLCBEQVRBQkFTRV9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGJQcm9taXNlO1xyXG59XHJcbi8qKiBBc3NpZ25zIG9yIG92ZXJ3cml0ZXMgdGhlIHJlY29yZCBmb3IgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2V0KGFwcENvbmZpZywgdmFsdWUpIHtcclxuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xyXG4gICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcclxuICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSAoYXdhaXQgb2JqZWN0U3RvcmUuZ2V0KGtleSkpO1xyXG4gICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KHZhbHVlLCBrZXkpO1xyXG4gICAgYXdhaXQgdHguZG9uZTtcclxuICAgIGlmICghb2xkVmFsdWUgfHwgb2xkVmFsdWUuZmlkICE9PSB2YWx1ZS5maWQpIHtcclxuICAgICAgICBmaWRDaGFuZ2VkKGFwcENvbmZpZywgdmFsdWUuZmlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKiogUmVtb3ZlcyByZWNvcmQocykgZnJvbSB0aGUgb2JqZWN0U3RvcmUgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4ga2V5LiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZW1vdmUoYXBwQ29uZmlnKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICBhd2FpdCB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfTkFNRSkuZGVsZXRlKGtleSk7XHJcbiAgICBhd2FpdCB0eC5kb25lO1xyXG59XHJcbi8qKlxyXG4gKiBBdG9taWNhbGx5IHVwZGF0ZXMgYSByZWNvcmQgd2l0aCB0aGUgcmVzdWx0IG9mIHVwZGF0ZUZuLCB3aGljaCBnZXRzXHJcbiAqIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlLiBJZiBuZXdWYWx1ZSBpcyB1bmRlZmluZWQsIHRoZSByZWNvcmQgaXNcclxuICogZGVsZXRlZCBpbnN0ZWFkLlxyXG4gKiBAcmV0dXJuIFVwZGF0ZWQgdmFsdWVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZShhcHBDb25maWcsIHVwZGF0ZUZuKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gKGF3YWl0IHN0b3JlLmdldChrZXkpKTtcclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdXBkYXRlRm4ob2xkVmFsdWUpO1xyXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhd2FpdCBzdG9yZS5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHN0b3JlLnB1dChuZXdWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICBpZiAobmV3VmFsdWUgJiYgKCFvbGRWYWx1ZSB8fCBvbGRWYWx1ZS5maWQgIT09IG5ld1ZhbHVlLmZpZCkpIHtcclxuICAgICAgICBmaWRDaGFuZ2VkKGFwcENvbmZpZywgbmV3VmFsdWUuZmlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdWYWx1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXBkYXRlcyBhbmQgcmV0dXJucyB0aGUgSW5zdGFsbGF0aW9uRW50cnkgZnJvbSB0aGUgZGF0YWJhc2UuXHJcbiAqIEFsc28gdHJpZ2dlcnMgYSByZWdpc3RyYXRpb24gcmVxdWVzdCBpZiBpdCBpcyBuZWNlc3NhcnkgYW5kIHBvc3NpYmxlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5zdGFsbGF0aW9uRW50cnkoaW5zdGFsbGF0aW9ucykge1xyXG4gICAgbGV0IHJlZ2lzdHJhdGlvblByb21pc2U7XHJcbiAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IGF3YWl0IHVwZGF0ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxhdGlvbkVudHJ5ID0gdXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeShvbGRFbnRyeSk7XHJcbiAgICAgICAgY29uc3QgZW50cnlXaXRoUHJvbWlzZSA9IHRyaWdnZXJSZWdpc3RyYXRpb25JZk5lY2Vzc2FyeShpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IGVudHJ5V2l0aFByb21pc2UucmVnaXN0cmF0aW9uUHJvbWlzZTtcclxuICAgICAgICByZXR1cm4gZW50cnlXaXRoUHJvbWlzZS5pbnN0YWxsYXRpb25FbnRyeTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGluc3RhbGxhdGlvbkVudHJ5LmZpZCA9PT0gSU5WQUxJRF9GSUQpIHtcclxuICAgICAgICAvLyBGSUQgZ2VuZXJhdGlvbiBmYWlsZWQuIFdhaXRpbmcgZm9yIHRoZSBGSUQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgIHJldHVybiB7IGluc3RhbGxhdGlvbkVudHJ5OiBhd2FpdCByZWdpc3RyYXRpb25Qcm9taXNlIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LFxyXG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2VcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgSW5zdGFsbGF0aW9uIEVudHJ5IGlmIG9uZSBkb2VzIG5vdCBleGlzdC5cclxuICogQWxzbyBjbGVhcnMgdGltZWQgb3V0IHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVPckNyZWF0ZUluc3RhbGxhdGlvbkVudHJ5KG9sZEVudHJ5KSB7XHJcbiAgICBjb25zdCBlbnRyeSA9IG9sZEVudHJ5IHx8IHtcclxuICAgICAgICBmaWQ6IGdlbmVyYXRlRmlkKCksXHJcbiAgICAgICAgcmVnaXN0cmF0aW9uU3RhdHVzOiAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi9cclxuICAgIH07XHJcbiAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpO1xyXG59XHJcbi8qKlxyXG4gKiBJZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIG5vdCByZWdpc3RlcmVkIHlldCwgdGhpcyB3aWxsIHRyaWdnZXIgdGhlXHJcbiAqIHJlZ2lzdHJhdGlvbiBhbmQgcmV0dXJuIGFuIEluUHJvZ3Jlc3NJbnN0YWxsYXRpb25FbnRyeS5cclxuICpcclxuICogSWYgcmVnaXN0cmF0aW9uUHJvbWlzZSBkb2VzIG5vdCBleGlzdCwgdGhlIGluc3RhbGxhdGlvbkVudHJ5IGlzIGd1YXJhbnRlZWRcclxuICogdG8gYmUgcmVnaXN0ZXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWdpc3RyYXRpb25JZk5lY2Vzc2FyeShpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xyXG4gICAgaWYgKGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XHJcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XHJcbiAgICAgICAgICAgIC8vIFJlZ2lzdHJhdGlvbiByZXF1aXJlZCBidXQgYXBwIGlzIG9mZmxpbmUuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvblByb21pc2VXaXRoRXJyb3IgPSBQcm9taXNlLnJlamVjdChFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1vZmZsaW5lXCIgLyogRXJyb3JDb2RlLkFQUF9PRkZMSU5FICovKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YWxsYXRpb25FbnRyeSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2U6IHJlZ2lzdHJhdGlvblByb21pc2VXaXRoRXJyb3JcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHJlZ2lzdGVyaW5nLiBDaGFuZ2Ugc3RhdHVzIHRvIElOX1BST0dSRVNTLlxyXG4gICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NFbnRyeSA9IHtcclxuICAgICAgICAgICAgZmlkOiBpbnN0YWxsYXRpb25FbnRyeS5maWQsXHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovLFxyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25UaW1lOiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZWdpc3RyYXRpb25Qcm9taXNlID0gcmVnaXN0ZXJJbnN0YWxsYXRpb24oaW5zdGFsbGF0aW9ucywgaW5Qcm9ncmVzc0VudHJ5KTtcclxuICAgICAgICByZXR1cm4geyBpbnN0YWxsYXRpb25FbnRyeTogaW5Qcm9ncmVzc0VudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LFxyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlOiB3YWl0VW50aWxGaWRSZWdpc3RyYXRpb24oaW5zdGFsbGF0aW9ucylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uRW50cnkgfTtcclxuICAgIH1cclxufVxyXG4vKiogVGhpcyB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgb25jZSBmb3IgZWFjaCBuZXcgRmlyZWJhc2UgSW5zdGFsbGF0aW9uLiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbihpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnkgPSBhd2FpdCBjcmVhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgICAgICByZXR1cm4gc2V0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNTZXJ2ZXJFcnJvcihlKSAmJiBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA5KSB7XHJcbiAgICAgICAgICAgIC8vIFNlcnZlciByZXR1cm5lZCBhIFwiRklEIGNhbiBub3QgYmUgdXNlZFwiIGVycm9yLlxyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBJRCBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZWdpc3RyYXRpb24gZmFpbGVkLiBTZXQgRklEIGFzIG5vdCByZWdpc3RlcmVkLlxyXG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHtcclxuICAgICAgICAgICAgICAgIGZpZDogaW5zdGFsbGF0aW9uRW50cnkuZmlkLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uU3RhdHVzOiAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbn1cclxuLyoqIENhbGwgaWYgRklEIHJlZ2lzdHJhdGlvbiBpcyBwZW5kaW5nIGluIGFub3RoZXIgcmVxdWVzdC4gKi9cclxuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpIHtcclxuICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlIGlzIG5vIHdheSBvZiByZWxpYWJseSBvYnNlcnZpbmcgd2hlbiBhIHZhbHVlIGluXHJcbiAgICAvLyBJbmRleGVkREIgY2hhbmdlcyAoeWV0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvaW5kZXhlZC1kYi1vYnNlcnZlcnMpLFxyXG4gICAgLy8gc28gd2UgbmVlZCB0byBwb2xsLlxyXG4gICAgbGV0IGVudHJ5ID0gYXdhaXQgdXBkYXRlSW5zdGFsbGF0aW9uUmVxdWVzdChpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XHJcbiAgICB3aGlsZSAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcclxuICAgICAgICAvLyBjcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdCBzdGlsbCBpbiBwcm9ncmVzcy5cclxuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xyXG4gICAgICAgIGVudHJ5ID0gYXdhaXQgdXBkYXRlSW5zdGFsbGF0aW9uUmVxdWVzdChpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi8pIHtcclxuICAgICAgICAvLyBUaGUgcmVxdWVzdCB0aW1lZCBvdXQgb3IgZmFpbGVkIGluIGEgZGlmZmVyZW50IGNhbGwuIFRyeSBhZ2Fpbi5cclxuICAgICAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zKTtcclxuICAgICAgICBpZiAocmVnaXN0cmF0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHJlZ2lzdHJhdGlvblByb21pc2UsIGVudHJ5IGlzIHJlZ2lzdGVyZWQuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxlZCBvbmx5IGlmIHRoZXJlIGlzIGEgQ3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXHJcbiAqXHJcbiAqIFVwZGF0ZXMgdGhlIEluc3RhbGxhdGlvbkVudHJ5IGluIHRoZSBEQiBiYXNlZCBvbiB0aGUgc3RhdHVzIG9mIHRoZVxyXG4gKiBDcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cclxuICpcclxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBJbnN0YWxsYXRpb25FbnRyeS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZUluc3RhbGxhdGlvblJlcXVlc3QoYXBwQ29uZmlnKSB7XHJcbiAgICByZXR1cm4gdXBkYXRlKGFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xyXG4gICAgICAgIGlmICghb2xkRW50cnkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnN0YWxsYXRpb24tbm90LWZvdW5kXCIgLyogRXJyb3JDb2RlLklOU1RBTExBVElPTl9OT1RfRk9VTkQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3Qob2xkRW50cnkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpIHtcclxuICAgIGlmIChoYXNJbnN0YWxsYXRpb25SZXF1ZXN0VGltZWRPdXQoZW50cnkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlkOiBlbnRyeS5maWQsXHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRyeTtcclxufVxyXG5mdW5jdGlvbiBoYXNJbnN0YWxsYXRpb25SZXF1ZXN0VGltZWRPdXQoaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIHJldHVybiAoaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8gJiZcclxuICAgICAgICBpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25UaW1lICsgUEVORElOR19USU1FT1VUX01TIDwgRGF0ZS5ub3coKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVBdXRoVG9rZW5SZXF1ZXN0KHsgYXBwQ29uZmlnLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgfSwgaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0R2VuZXJhdGVBdXRoVG9rZW5FbmRwb2ludChhcHBDb25maWcsIGluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAvLyBJZiBoZWFydGJlYXQgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgaGVhcnRiZWF0IHN0cmluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0U2VydmljZSA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGlmIChoZWFydGJlYXRTZXJ2aWNlKSB7XHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0IGhlYXJ0YmVhdFNlcnZpY2UuZ2V0SGVhcnRiZWF0c0hlYWRlcigpO1xyXG4gICAgICAgIGlmIChoZWFydGJlYXRzSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCd4LWZpcmViYXNlLWNsaWVudCcsIGhlYXJ0YmVhdHNIZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGJvZHkgPSB7XHJcbiAgICAgICAgaW5zdGFsbGF0aW9uOiB7XHJcbiAgICAgICAgICAgIHNka1ZlcnNpb246IFBBQ0tBR0VfVkVSU0lPTixcclxuICAgICAgICAgICAgYXBwSWQ6IGFwcENvbmZpZy5hcHBJZFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5SWZTZXJ2ZXJFcnJvcigoKSA9PiBmZXRjaChlbmRwb2ludCwgcmVxdWVzdCkpO1xyXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZWRBdXRoVG9rZW4gPSBleHRyYWN0QXV0aFRva2VuSW5mb0Zyb21SZXNwb25zZShyZXNwb25zZVZhbHVlKTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGVkQXV0aFRva2VuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgYXdhaXQgZ2V0RXJyb3JGcm9tUmVzcG9uc2UoJ0dlbmVyYXRlIEF1dGggVG9rZW4nLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVBdXRoVG9rZW5FbmRwb2ludChhcHBDb25maWcsIHsgZmlkIH0pIHtcclxuICAgIHJldHVybiBgJHtnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKX0vJHtmaWR9L2F1dGhUb2tlbnM6Z2VuZXJhdGVgO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHRoZSBpbnN0YWxsYXRpb24uIEdlbmVyYXRlcyBhIG5ld1xyXG4gKiB0b2tlbiBpZiBvbmUgZG9lc24ndCBleGlzdCwgaXMgZXhwaXJlZCBvciBhYm91dCB0byBleHBpcmUuXHJcbiAqXHJcbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIHJlZ2lzdGVyZWQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgdG9rZW5Qcm9taXNlO1xyXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB1cGRhdGUoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcclxuICAgICAgICBpZiAoIWlzRW50cnlSZWdpc3RlcmVkKG9sZEVudHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2xkQXV0aFRva2VuID0gb2xkRW50cnkuYXV0aFRva2VuO1xyXG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzQXV0aFRva2VuVmFsaWQob2xkQXV0aFRva2VuKSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHZhbGlkIHRva2VuIGluIHRoZSBEQi5cclxuICAgICAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvbGRBdXRoVG9rZW4ucmVxdWVzdFN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFscmVhZHkgaXMgYSB0b2tlbiByZXF1ZXN0IGluIHByb2dyZXNzLlxyXG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSB3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRFbnRyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHRva2VuIG9yIHRva2VuIGV4cGlyZWQuXHJcbiAgICAgICAgICAgIGlmICghbmF2aWdhdG9yLm9uTGluZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW5Qcm9ncmVzc0VudHJ5ID0gbWFrZUF1dGhUb2tlblJlcXVlc3RJblByb2dyZXNzRW50cnkob2xkRW50cnkpO1xyXG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSBmZXRjaEF1dGhUb2tlbkZyb21TZXJ2ZXIoaW5zdGFsbGF0aW9ucywgaW5Qcm9ncmVzc0VudHJ5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NFbnRyeTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGF1dGhUb2tlbiA9IHRva2VuUHJvbWlzZVxyXG4gICAgICAgID8gYXdhaXQgdG9rZW5Qcm9taXNlXHJcbiAgICAgICAgOiBlbnRyeS5hdXRoVG9rZW47XHJcbiAgICByZXR1cm4gYXV0aFRva2VuO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsIG9ubHkgaWYgRklEIGlzIHJlZ2lzdGVyZWQgYW5kIEF1dGggVG9rZW4gcmVxdWVzdCBpcyBpbiBwcm9ncmVzcy5cclxuICpcclxuICogV2FpdHMgdW50aWwgdGhlIGN1cnJlbnQgcGVuZGluZyByZXF1ZXN0IGZpbmlzaGVzLiBJZiB0aGUgcmVxdWVzdCB0aW1lcyBvdXQsXHJcbiAqIHRyaWVzIG9uY2UgaW4gdGhpcyB0aHJlYWQgYXMgd2VsbC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbEF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSBpcyBubyB3YXkgb2YgcmVsaWFibHkgb2JzZXJ2aW5nIHdoZW4gYSB2YWx1ZSBpblxyXG4gICAgLy8gSW5kZXhlZERCIGNoYW5nZXMgKHlldCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2luZGV4ZWQtZGItb2JzZXJ2ZXJzKSxcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9sbC5cclxuICAgIGxldCBlbnRyeSA9IGF3YWl0IHVwZGF0ZUF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xyXG4gICAgd2hpbGUgKGVudHJ5LmF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZUF1dGhUb2tlbiBzdGlsbCBpbiBwcm9ncmVzcy5cclxuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xyXG4gICAgICAgIGVudHJ5ID0gYXdhaXQgdXBkYXRlQXV0aFRva2VuUmVxdWVzdChpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoVG9rZW4gPSBlbnRyeS5hdXRoVG9rZW47XHJcbiAgICBpZiAoYXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLykge1xyXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IHRpbWVkIG91dCBvciBmYWlsZWQgaW4gYSBkaWZmZXJlbnQgY2FsbC4gVHJ5IGFnYWluLlxyXG4gICAgICAgIHJldHVybiByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXV0aFRva2VuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgb25seSBpZiB0aGVyZSBpcyBhIEdlbmVyYXRlQXV0aFRva2VuIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXHJcbiAqXHJcbiAqIFVwZGF0ZXMgdGhlIEluc3RhbGxhdGlvbkVudHJ5IGluIHRoZSBEQiBiYXNlZCBvbiB0aGUgc3RhdHVzIG9mIHRoZVxyXG4gKiBHZW5lcmF0ZUF1dGhUb2tlbiByZXF1ZXN0LlxyXG4gKlxyXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlQXV0aFRva2VuUmVxdWVzdChhcHBDb25maWcpIHtcclxuICAgIHJldHVybiB1cGRhdGUoYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0VudHJ5UmVnaXN0ZXJlZChvbGRFbnRyeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJub3QtcmVnaXN0ZXJlZFwiIC8qIEVycm9yQ29kZS5OT1RfUkVHSVNURVJFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEF1dGhUb2tlbiA9IG9sZEVudHJ5LmF1dGhUb2tlbjtcclxuICAgICAgICBpZiAoaGFzQXV0aFRva2VuUmVxdWVzdFRpbWVkT3V0KG9sZEF1dGhUb2tlbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkRW50cnkpLCB7IGF1dGhUb2tlbjogeyByZXF1ZXN0U3RhdHVzOiAwIC8qIFJlcXVlc3RTdGF0dXMuTk9UX1NUQVJURUQgKi8gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoVG9rZW5Gcm9tU2VydmVyKGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGF1dGhUb2tlbiA9IGF3YWl0IGdlbmVyYXRlQXV0aFRva2VuUmVxdWVzdChpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YWxsYXRpb25FbnRyeSksIHsgYXV0aFRva2VuIH0pO1xyXG4gICAgICAgIGF3YWl0IHNldChpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgICAgICByZXR1cm4gYXV0aFRva2VuO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNTZXJ2ZXJFcnJvcihlKSAmJlxyXG4gICAgICAgICAgICAoZS5jdXN0b21EYXRhLnNlcnZlckNvZGUgPT09IDQwMSB8fCBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA0KSkge1xyXG4gICAgICAgICAgICAvLyBTZXJ2ZXIgcmV0dXJuZWQgYSBcIkZJRCBub3QgZm91bmRcIiBvciBhIFwiSW52YWxpZCBhdXRoZW50aWNhdGlvblwiIGVycm9yLlxyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBJRCBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW5zdGFsbGF0aW9uRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbGxhdGlvbkVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldChpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0VudHJ5UmVnaXN0ZXJlZChpbnN0YWxsYXRpb25FbnRyeSkge1xyXG4gICAgcmV0dXJuIChpbnN0YWxsYXRpb25FbnRyeSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovKTtcclxufVxyXG5mdW5jdGlvbiBpc0F1dGhUb2tlblZhbGlkKGF1dGhUb2tlbikge1xyXG4gICAgcmV0dXJuIChhdXRoVG9rZW4ucmVxdWVzdFN0YXR1cyA9PT0gMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLyAmJlxyXG4gICAgICAgICFpc0F1dGhUb2tlbkV4cGlyZWQoYXV0aFRva2VuKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNBdXRoVG9rZW5FeHBpcmVkKGF1dGhUb2tlbikge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIHJldHVybiAobm93IDwgYXV0aFRva2VuLmNyZWF0aW9uVGltZSB8fFxyXG4gICAgICAgIGF1dGhUb2tlbi5jcmVhdGlvblRpbWUgKyBhdXRoVG9rZW4uZXhwaXJlc0luIDwgbm93ICsgVE9LRU5fRVhQSVJBVElPTl9CVUZGRVIpO1xyXG59XHJcbi8qKiBSZXR1cm5zIGFuIHVwZGF0ZWQgSW5zdGFsbGF0aW9uRW50cnkgd2l0aCBhbiBJblByb2dyZXNzQXV0aFRva2VuLiAqL1xyXG5mdW5jdGlvbiBtYWtlQXV0aFRva2VuUmVxdWVzdEluUHJvZ3Jlc3NFbnRyeShvbGRFbnRyeSkge1xyXG4gICAgY29uc3QgaW5Qcm9ncmVzc0F1dGhUb2tlbiA9IHtcclxuICAgICAgICByZXF1ZXN0U3RhdHVzOiAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8sXHJcbiAgICAgICAgcmVxdWVzdFRpbWU6IERhdGUubm93KClcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRFbnRyeSksIHsgYXV0aFRva2VuOiBpblByb2dyZXNzQXV0aFRva2VuIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0F1dGhUb2tlblJlcXVlc3RUaW1lZE91dChhdXRoVG9rZW4pIHtcclxuICAgIHJldHVybiAoYXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLyAmJlxyXG4gICAgICAgIGF1dGhUb2tlbi5yZXF1ZXN0VGltZSArIFBFTkRJTkdfVElNRU9VVF9NUyA8IERhdGUubm93KCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlmIHRoZXJlIGlzbid0IG9uZSBmb3IgdGhlIGFwcCBhbmRcclxuICogcmV0dXJucyB0aGUgSW5zdGFsbGF0aW9uIElELlxyXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldElkKGluc3RhbGxhdGlvbnMpIHtcclxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcclxuICAgIGNvbnN0IHsgaW5zdGFsbGF0aW9uRW50cnksIHJlZ2lzdHJhdGlvblByb21pc2UgfSA9IGF3YWl0IGdldEluc3RhbGxhdGlvbkVudHJ5KGluc3RhbGxhdGlvbnNJbXBsKTtcclxuICAgIGlmIChyZWdpc3RyYXRpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElmIHRoZSBpbnN0YWxsYXRpb24gaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB1cGRhdGUgdGhlIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgICAgLy8gdG9rZW4gaWYgbmVlZGVkLlxyXG4gICAgICAgIHJlZnJlc2hBdXRoVG9rZW4oaW5zdGFsbGF0aW9uc0ltcGwpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3RhbGxhdGlvbkVudHJ5LmZpZDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIEZpcmViYXNlIEluc3RhbGxhdGlvbnMgYXV0aCB0b2tlbiwgaWRlbnRpZnlpbmcgdGhlIGN1cnJlbnRcclxuICogRmlyZWJhc2UgSW5zdGFsbGF0aW9uLlxyXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcclxuICAgIGF3YWl0IGNvbXBsZXRlSW5zdGFsbGF0aW9uUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnNJbXBsKTtcclxuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgZWl0aGVyIGhhdmUgYSBSZWdpc3RlcmVkIEluc3RhbGxhdGlvbiBpbiB0aGUgREIsIG9yIHdlJ3ZlXHJcbiAgICAvLyBhbHJlYWR5IHRocm93biBhbiBlcnJvci5cclxuICAgIGNvbnN0IGF1dGhUb2tlbiA9IGF3YWl0IHJlZnJlc2hBdXRoVG9rZW4oaW5zdGFsbGF0aW9uc0ltcGwsIGZvcmNlUmVmcmVzaCk7XHJcbiAgICByZXR1cm4gYXV0aFRva2VuLnRva2VuO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlSW5zdGFsbGF0aW9uUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgcmVnaXN0cmF0aW9uUHJvbWlzZSB9ID0gYXdhaXQgZ2V0SW5zdGFsbGF0aW9uRW50cnkoaW5zdGFsbGF0aW9ucyk7XHJcbiAgICBpZiAocmVnaXN0cmF0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgIC8vIEEgY3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MuIFdhaXQgdW50aWwgaXQgZmluaXNoZXMuXHJcbiAgICAgICAgYXdhaXQgcmVnaXN0cmF0aW9uUHJvbWlzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0RGVsZXRlRW5kcG9pbnQoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVyc1dpdGhBdXRoKGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgIGhlYWRlcnNcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5SWZTZXJ2ZXJFcnJvcigoKSA9PiBmZXRjaChlbmRwb2ludCwgcmVxdWVzdCkpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IGF3YWl0IGdldEVycm9yRnJvbVJlc3BvbnNlKCdEZWxldGUgSW5zdGFsbGF0aW9uJywgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldERlbGV0ZUVuZHBvaW50KGFwcENvbmZpZywgeyBmaWQgfSkge1xyXG4gICAgcmV0dXJuIGAke2dldEluc3RhbGxhdGlvbnNFbmRwb2ludChhcHBDb25maWcpfS8ke2ZpZH1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWxldGVzIHRoZSBGaXJlYmFzZSBJbnN0YWxsYXRpb24gYW5kIGFsbCBhc3NvY2lhdGVkIGRhdGEuXHJcbiAqIEBwYXJhbSBpbnN0YWxsYXRpb25zIC0gVGhlIGBJbnN0YWxsYXRpb25zYCBpbnN0YW5jZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW5zdGFsbGF0aW9ucyhpbnN0YWxsYXRpb25zKSB7XHJcbiAgICBjb25zdCB7IGFwcENvbmZpZyB9ID0gaW5zdGFsbGF0aW9ucztcclxuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdXBkYXRlKGFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xyXG4gICAgICAgIGlmIChvbGRFbnRyeSAmJiBvbGRFbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLykge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIHVucmVnaXN0ZXJlZCBlbnRyeSB3aXRob3V0IHNlbmRpbmcgYSBkZWxldGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xyXG4gICAgfSk7XHJcbiAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcclxuICAgICAgICAgICAgLy8gQ2FuJ3QgZGVsZXRlIHdoaWxlIHRyeWluZyB0byByZWdpc3Rlci5cclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkZWxldGUtcGVuZGluZy1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuREVMRVRFX1BFTkRJTkdfUkVHSVNUUkFUSU9OICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmICghbmF2aWdhdG9yLm9uTGluZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZywgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKGFwcENvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFNldHMgYSBuZXcgY2FsbGJhY2sgdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbiBJbnN0YWxsYXRpb24gSUQgY2hhbmdlcy5cclxuICogUmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBjYWxsYmFjayB3aGVuIGNhbGxlZC5cclxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW4gRklEIGNoYW5nZXMuXHJcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbklkQ2hhbmdlKGluc3RhbGxhdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCB7IGFwcENvbmZpZyB9ID0gaW5zdGFsbGF0aW9ucztcclxuICAgIGFkZENhbGxiYWNrKGFwcENvbmZpZywgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICByZW1vdmVDYWxsYmFjayhhcHBDb25maWcsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEluc3RhbGxhdGlvbnN9IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW5cclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW5zdGFsbGF0aW9ucyhhcHAgPSBnZXRBcHAoKSkge1xyXG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaW5zdGFsbGF0aW9ucycpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgcmV0dXJuIGluc3RhbGxhdGlvbnNJbXBsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RBcHBDb25maWcoYXBwKSB7XHJcbiAgICBpZiAoIWFwcCB8fCAhYXBwLm9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBnZXRNaXNzaW5nVmFsdWVFcnJvcignQXBwIENvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwLm5hbWUpIHtcclxuICAgICAgICB0aHJvdyBnZXRNaXNzaW5nVmFsdWVFcnJvcignQXBwIE5hbWUnKTtcclxuICAgIH1cclxuICAgIC8vIFJlcXVpcmVkIGFwcCBjb25maWcga2V5c1xyXG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtcclxuICAgICAgICAncHJvamVjdElkJyxcclxuICAgICAgICAnYXBpS2V5JyxcclxuICAgICAgICAnYXBwSWQnXHJcbiAgICBdO1xyXG4gICAgZm9yIChjb25zdCBrZXlOYW1lIG9mIGNvbmZpZ0tleXMpIHtcclxuICAgICAgICBpZiAoIWFwcC5vcHRpb25zW2tleU5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKGtleU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwTmFtZTogYXBwLm5hbWUsXHJcbiAgICAgICAgcHJvamVjdElkOiBhcHAub3B0aW9ucy5wcm9qZWN0SWQsXHJcbiAgICAgICAgYXBpS2V5OiBhcHAub3B0aW9ucy5hcGlLZXksXHJcbiAgICAgICAgYXBwSWQ6IGFwcC5vcHRpb25zLmFwcElkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pc3NpbmdWYWx1ZUVycm9yKHZhbHVlTmFtZSkge1xyXG4gICAgcmV0dXJuIEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibWlzc2luZy1hcHAtY29uZmlnLXZhbHVlc1wiIC8qIEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DT05GSUdfVkFMVUVTICovLCB7XHJcbiAgICAgICAgdmFsdWVOYW1lXHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUUgPSAnaW5zdGFsbGF0aW9ucyc7XHJcbmNvbnN0IElOU1RBTExBVElPTlNfTkFNRV9JTlRFUk5BTCA9ICdpbnN0YWxsYXRpb25zLWludGVybmFsJztcclxuY29uc3QgcHVibGljRmFjdG9yeSA9IChjb250YWluZXIpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAvLyBUaHJvd3MgaWYgYXBwIGlzbid0IGNvbmZpZ3VyZWQgcHJvcGVybHkuXHJcbiAgICBjb25zdCBhcHBDb25maWcgPSBleHRyYWN0QXBwQ29uZmlnKGFwcCk7XHJcbiAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaGVhcnRiZWF0Jyk7XHJcbiAgICBjb25zdCBpbnN0YWxsYXRpb25zSW1wbCA9IHtcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgYXBwQ29uZmlnLFxyXG4gICAgICAgIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlcixcclxuICAgICAgICBfZGVsZXRlOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBpbnN0YWxsYXRpb25zSW1wbDtcclxufTtcclxuY29uc3QgaW50ZXJuYWxGYWN0b3J5ID0gKGNvbnRhaW5lcikgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgIC8vIEludGVybmFsIEZJUyBpbnN0YW5jZSByZWxpZXMgb24gcHVibGljIEZJUyBpbnN0YW5jZS5cclxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnMgPSBfZ2V0UHJvdmlkZXIoYXBwLCBJTlNUQUxMQVRJT05TX05BTUUpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ludGVybmFsID0ge1xyXG4gICAgICAgIGdldElkOiAoKSA9PiBnZXRJZChpbnN0YWxsYXRpb25zKSxcclxuICAgICAgICBnZXRUb2tlbjogKGZvcmNlUmVmcmVzaCkgPT4gZ2V0VG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBpbnN0YWxsYXRpb25zSW50ZXJuYWw7XHJcbn07XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySW5zdGFsbGF0aW9ucygpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KElOU1RBTExBVElPTlNfTkFNRSwgcHVibGljRmFjdG9yeSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoSU5TVEFMTEFUSU9OU19OQU1FX0lOVEVSTkFMLCBpbnRlcm5hbEZhY3RvcnksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBJbnN0YWxsYXRpb25zXHJcbiAqXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJJbnN0YWxsYXRpb25zKCk7XHJcbnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcclxuLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG5cbmV4cG9ydCB7IGRlbGV0ZUluc3RhbGxhdGlvbnMsIGdldElkLCBnZXRJbnN0YWxsYXRpb25zLCBnZXRUb2tlbiwgb25JZENoYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0UHJvdmlkZXIiLCJnZXRBcHAiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJDb21wb25lbnQiLCJFcnJvckZhY3RvcnkiLCJGaXJlYmFzZUVycm9yIiwib3BlbkRCIiwibmFtZSIsInZlcnNpb24iLCJQRU5ESU5HX1RJTUVPVVRfTVMiLCJQQUNLQUdFX1ZFUlNJT04iLCJJTlRFUk5BTF9BVVRIX1ZFUlNJT04iLCJJTlNUQUxMQVRJT05TX0FQSV9VUkwiLCJUT0tFTl9FWFBJUkFUSU9OX0JVRkZFUiIsIlNFUlZJQ0UiLCJTRVJWSUNFX05BTUUiLCJFUlJPUl9ERVNDUklQVElPTl9NQVAiLCJFUlJPUl9GQUNUT1JZIiwiaXNTZXJ2ZXJFcnJvciIsImVycm9yIiwiY29kZSIsImluY2x1ZGVzIiwiZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50IiwicHJvamVjdElkIiwiZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UiLCJyZXNwb25zZSIsInRva2VuIiwicmVxdWVzdFN0YXR1cyIsImV4cGlyZXNJbiIsImdldEV4cGlyZXNJbkZyb21SZXNwb25zZUV4cGlyZXNJbiIsImNyZWF0aW9uVGltZSIsIkRhdGUiLCJub3ciLCJnZXRFcnJvckZyb21SZXNwb25zZSIsInJlcXVlc3ROYW1lIiwicmVzcG9uc2VKc29uIiwianNvbiIsImVycm9yRGF0YSIsImNyZWF0ZSIsInNlcnZlckNvZGUiLCJzZXJ2ZXJNZXNzYWdlIiwibWVzc2FnZSIsInNlcnZlclN0YXR1cyIsInN0YXR1cyIsImdldEhlYWRlcnMiLCJhcGlLZXkiLCJIZWFkZXJzIiwiQWNjZXB0IiwiZ2V0SGVhZGVyc1dpdGhBdXRoIiwiYXBwQ29uZmlnIiwicmVmcmVzaFRva2VuIiwiaGVhZGVycyIsImFwcGVuZCIsImdldEF1dGhvcml6YXRpb25IZWFkZXIiLCJyZXRyeUlmU2VydmVyRXJyb3IiLCJmbiIsInJlc3VsdCIsInJlc3BvbnNlRXhwaXJlc0luIiwiTnVtYmVyIiwicmVwbGFjZSIsImNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QiLCJoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIiLCJmaWQiLCJlbmRwb2ludCIsImhlYXJ0YmVhdFNlcnZpY2UiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25hbCIsImhlYXJ0YmVhdHNIZWFkZXIiLCJnZXRIZWFydGJlYXRzSGVhZGVyIiwiYm9keSIsImF1dGhWZXJzaW9uIiwiYXBwSWQiLCJzZGtWZXJzaW9uIiwicmVxdWVzdCIsIm1ldGhvZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmZXRjaCIsIm9rIiwicmVzcG9uc2VWYWx1ZSIsInJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSIsInJlZ2lzdHJhdGlvblN0YXR1cyIsImF1dGhUb2tlbiIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJidWZmZXJUb0Jhc2U2NFVybFNhZmUiLCJhcnJheSIsImI2NCIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJWQUxJRF9GSURfUEFUVEVSTiIsIklOVkFMSURfRklEIiwiZ2VuZXJhdGVGaWQiLCJmaWRCeXRlQXJyYXkiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwic2VsZiIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiZW5jb2RlIiwidGVzdCIsIl9hIiwiYjY0U3RyaW5nIiwic3Vic3RyIiwiZ2V0S2V5IiwiYXBwTmFtZSIsImZpZENoYW5nZUNhbGxiYWNrcyIsIk1hcCIsImZpZENoYW5nZWQiLCJrZXkiLCJjYWxsRmlkQ2hhbmdlQ2FsbGJhY2tzIiwiYnJvYWRjYXN0RmlkQ2hhbmdlIiwiYWRkQ2FsbGJhY2siLCJjYWxsYmFjayIsImdldEJyb2FkY2FzdENoYW5uZWwiLCJjYWxsYmFja1NldCIsImdldCIsIlNldCIsInNldCIsImFkZCIsInJlbW92ZUNhbGxiYWNrIiwiZGVsZXRlIiwic2l6ZSIsImNsb3NlQnJvYWRjYXN0Q2hhbm5lbCIsImNhbGxiYWNrcyIsImNoYW5uZWwiLCJwb3N0TWVzc2FnZSIsImJyb2FkY2FzdENoYW5uZWwiLCJCcm9hZGNhc3RDaGFubmVsIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJjbG9zZSIsIkRBVEFCQVNFX05BTUUiLCJEQVRBQkFTRV9WRVJTSU9OIiwiT0JKRUNUX1NUT1JFX05BTUUiLCJkYlByb21pc2UiLCJnZXREYlByb21pc2UiLCJ1cGdyYWRlIiwiZGIiLCJvbGRWZXJzaW9uIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJ2YWx1ZSIsInR4IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsIm9sZFZhbHVlIiwicHV0IiwiZG9uZSIsInJlbW92ZSIsInVwZGF0ZSIsInVwZGF0ZUZuIiwic3RvcmUiLCJuZXdWYWx1ZSIsInVuZGVmaW5lZCIsImdldEluc3RhbGxhdGlvbkVudHJ5IiwiaW5zdGFsbGF0aW9ucyIsInJlZ2lzdHJhdGlvblByb21pc2UiLCJpbnN0YWxsYXRpb25FbnRyeSIsIm9sZEVudHJ5IiwidXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeSIsImVudHJ5V2l0aFByb21pc2UiLCJ0cmlnZ2VyUmVnaXN0cmF0aW9uSWZOZWNlc3NhcnkiLCJlbnRyeSIsImNsZWFyVGltZWRPdXRSZXF1ZXN0IiwibmF2aWdhdG9yIiwib25MaW5lIiwicmVnaXN0cmF0aW9uUHJvbWlzZVdpdGhFcnJvciIsInJlamVjdCIsImluUHJvZ3Jlc3NFbnRyeSIsInJlZ2lzdHJhdGlvblRpbWUiLCJyZWdpc3Rlckluc3RhbGxhdGlvbiIsIndhaXRVbnRpbEZpZFJlZ2lzdHJhdGlvbiIsImN1c3RvbURhdGEiLCJ1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0IiwiaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0IiwiZ2VuZXJhdGVBdXRoVG9rZW5SZXF1ZXN0IiwiZ2V0R2VuZXJhdGVBdXRoVG9rZW5FbmRwb2ludCIsImluc3RhbGxhdGlvbiIsImNvbXBsZXRlZEF1dGhUb2tlbiIsInJlZnJlc2hBdXRoVG9rZW4iLCJmb3JjZVJlZnJlc2giLCJ0b2tlblByb21pc2UiLCJpc0VudHJ5UmVnaXN0ZXJlZCIsIm9sZEF1dGhUb2tlbiIsImlzQXV0aFRva2VuVmFsaWQiLCJ3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0IiwibWFrZUF1dGhUb2tlblJlcXVlc3RJblByb2dyZXNzRW50cnkiLCJmZXRjaEF1dGhUb2tlbkZyb21TZXJ2ZXIiLCJ1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0IiwiaGFzQXV0aFRva2VuUmVxdWVzdFRpbWVkT3V0IiwiT2JqZWN0IiwiYXNzaWduIiwidXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5IiwiaXNBdXRoVG9rZW5FeHBpcmVkIiwiaW5Qcm9ncmVzc0F1dGhUb2tlbiIsInJlcXVlc3RUaW1lIiwiZ2V0SWQiLCJpbnN0YWxsYXRpb25zSW1wbCIsImNhdGNoIiwiY29uc29sZSIsImdldFRva2VuIiwiY29tcGxldGVJbnN0YWxsYXRpb25SZWdpc3RyYXRpb24iLCJkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0IiwiZ2V0RGVsZXRlRW5kcG9pbnQiLCJkZWxldGVJbnN0YWxsYXRpb25zIiwib25JZENoYW5nZSIsImdldEluc3RhbGxhdGlvbnMiLCJhcHAiLCJleHRyYWN0QXBwQ29uZmlnIiwib3B0aW9ucyIsImdldE1pc3NpbmdWYWx1ZUVycm9yIiwiY29uZmlnS2V5cyIsImtleU5hbWUiLCJ2YWx1ZU5hbWUiLCJJTlNUQUxMQVRJT05TX05BTUUiLCJJTlNUQUxMQVRJT05TX05BTUVfSU5URVJOQUwiLCJwdWJsaWNGYWN0b3J5IiwiY29udGFpbmVyIiwiZ2V0UHJvdmlkZXIiLCJfZGVsZXRlIiwiaW50ZXJuYWxGYWN0b3J5IiwiaW5zdGFsbGF0aW9uc0ludGVybmFsIiwicmVnaXN0ZXJJbnN0YWxsYXRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@firebase/installations/node_modules/idb/build/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: function() { return /* binding */ deleteDB; },\n/* harmony export */   openDB: function() { return /* binding */ openDB; },\n/* harmony export */   unwrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u; },\n/* harmony export */   wrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w; }\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/wrap-idb-value.js\");\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */ function openDB(name, version) {\n    let { blocked, upgrade, blocking, terminated } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener(\"upgradeneeded\", (event)=>{\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));\n        });\n    }\n    if (blocked) request.addEventListener(\"blocked\", ()=>blocked());\n    openPromise.then((db)=>{\n        if (terminated) db.addEventListener(\"close\", ()=>terminated());\n        if (blocking) db.addEventListener(\"versionchange\", ()=>blocking());\n    }).catch(()=>{});\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */ function deleteDB(name) {\n    let { blocked } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) request.addEventListener(\"blocked\", ()=>blocked());\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(()=>undefined);\n}\nconst readMethods = [\n    \"get\",\n    \"getKey\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"count\"\n];\nconst writeMethods = [\n    \"put\",\n    \"add\",\n    \"delete\",\n    \"clear\"\n];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n        return;\n    }\n    if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, \"\");\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function(storeName) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps)=>({\n        ...oldTraps,\n        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1FO0FBQ047QUFFN0Q7Ozs7OztDQU1DLEdBQ0QsU0FBU00sT0FBT0MsSUFBSSxFQUFFQyxPQUFPO1FBQUUsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFLEdBQTFDLGlFQUE2QyxDQUFDO0lBQ3pFLE1BQU1DLFVBQVVDLFVBQVVDLElBQUksQ0FBQ1IsTUFBTUM7SUFDckMsTUFBTVEsY0FBY2YscURBQUlBLENBQUNZO0lBQ3pCLElBQUlILFNBQVM7UUFDVEcsUUFBUUksZ0JBQWdCLENBQUMsaUJBQWlCLENBQUNDO1lBQ3ZDUixRQUFRVCxxREFBSUEsQ0FBQ1ksUUFBUU0sTUFBTSxHQUFHRCxNQUFNRSxVQUFVLEVBQUVGLE1BQU1HLFVBQVUsRUFBRXBCLHFEQUFJQSxDQUFDWSxRQUFRUyxXQUFXO1FBQzlGO0lBQ0o7SUFDQSxJQUFJYixTQUNBSSxRQUFRSSxnQkFBZ0IsQ0FBQyxXQUFXLElBQU1SO0lBQzlDTyxZQUNLTyxJQUFJLENBQUMsQ0FBQ0M7UUFDUCxJQUFJWixZQUNBWSxHQUFHUCxnQkFBZ0IsQ0FBQyxTQUFTLElBQU1MO1FBQ3ZDLElBQUlELFVBQ0FhLEdBQUdQLGdCQUFnQixDQUFDLGlCQUFpQixJQUFNTjtJQUNuRCxHQUNLYyxLQUFLLENBQUMsS0FBUTtJQUNuQixPQUFPVDtBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNVLFNBQVNuQixJQUFJO1FBQUUsRUFBRUUsT0FBTyxFQUFFLEdBQVgsaUVBQWMsQ0FBQztJQUNuQyxNQUFNSSxVQUFVQyxVQUFVYSxjQUFjLENBQUNwQjtJQUN6QyxJQUFJRSxTQUNBSSxRQUFRSSxnQkFBZ0IsQ0FBQyxXQUFXLElBQU1SO0lBQzlDLE9BQU9SLHFEQUFJQSxDQUFDWSxTQUFTVSxJQUFJLENBQUMsSUFBTUs7QUFDcEM7QUFFQSxNQUFNQyxjQUFjO0lBQUM7SUFBTztJQUFVO0lBQVU7SUFBYztDQUFRO0FBQ3RFLE1BQU1DLGVBQWU7SUFBQztJQUFPO0lBQU87SUFBVTtDQUFRO0FBQ3RELE1BQU1DLGdCQUFnQixJQUFJQztBQUMxQixTQUFTQyxVQUFVQyxNQUFNLEVBQUVDLElBQUk7SUFDM0IsSUFBSSxDQUFFRCxDQUFBQSxrQkFBa0JFLGVBQ3BCLENBQUVELENBQUFBLFFBQVFELE1BQUssS0FDZixPQUFPQyxTQUFTLFFBQU8sR0FBSTtRQUMzQjtJQUNKO0lBQ0EsSUFBSUosY0FBY00sR0FBRyxDQUFDRixPQUNsQixPQUFPSixjQUFjTSxHQUFHLENBQUNGO0lBQzdCLE1BQU1HLGlCQUFpQkgsS0FBS0ksT0FBTyxDQUFDLGNBQWM7SUFDbEQsTUFBTUMsV0FBV0wsU0FBU0c7SUFDMUIsTUFBTUcsVUFBVVgsYUFBYVksUUFBUSxDQUFDSjtJQUN0QyxJQUNBLDRFQUE0RTtJQUM1RSxDQUFFQSxDQUFBQSxrQkFBa0IsQ0FBQ0UsV0FBV0csV0FBV0MsY0FBYSxFQUFHQyxTQUFTLEtBQ2hFLENBQUVKLENBQUFBLFdBQVdaLFlBQVlhLFFBQVEsQ0FBQ0osZUFBYyxHQUFJO1FBQ3BEO0lBQ0o7SUFDQSxNQUFNUSxTQUFTLGVBQWdCQyxTQUFTO1FBQUU7WUFBR0MsS0FBSCwyQkFBTzs7UUFDN0Msd0VBQXdFO1FBQ3hFLE1BQU1DLEtBQUssSUFBSSxDQUFDM0IsV0FBVyxDQUFDeUIsV0FBV04sVUFBVSxjQUFjO1FBQy9ELElBQUlQLFNBQVNlLEdBQUdDLEtBQUs7UUFDckIsSUFBSVYsVUFDQU4sU0FBU0EsT0FBT2lCLEtBQUssQ0FBQ0gsS0FBS0ksS0FBSztRQUNwQyw2QkFBNkI7UUFDN0IsNkRBQTZEO1FBQzdELHVDQUF1QztRQUN2Qyw4QkFBOEI7UUFDOUIsc0RBQXNEO1FBQ3RELE9BQU8sQ0FBQyxNQUFNQyxRQUFRQyxHQUFHLENBQUM7WUFDdEJwQixNQUFNLENBQUNJLGVBQWUsSUFBSVU7WUFDMUJQLFdBQVdRLEdBQUdNLElBQUk7U0FDckIsRUFBRSxDQUFDLEVBQUU7SUFDVjtJQUNBeEIsY0FBY3lCLEdBQUcsQ0FBQ3JCLE1BQU1XO0lBQ3hCLE9BQU9BO0FBQ1g7QUFDQTNDLHFEQUFZQSxDQUFDLENBQUNzRCxXQUFjO1FBQ3hCLEdBQUdBLFFBQVE7UUFDWHBCLEtBQUssQ0FBQ0gsUUFBUUMsTUFBTXVCLFdBQWF6QixVQUFVQyxRQUFRQyxTQUFTc0IsU0FBU3BCLEdBQUcsQ0FBQ0gsUUFBUUMsTUFBTXVCO1FBQ3ZGQyxLQUFLLENBQUN6QixRQUFRQyxPQUFTLENBQUMsQ0FBQ0YsVUFBVUMsUUFBUUMsU0FBU3NCLFNBQVNFLEdBQUcsQ0FBQ3pCLFFBQVFDO0lBQzdFO0FBRTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzPzg1MjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuZXhwb3J0IHsgdSBhcyB1bndyYXAsIHcgYXMgd3JhcCB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIFNjaGVtYSB2ZXJzaW9uLlxuICogQHBhcmFtIGNhbGxiYWNrcyBBZGRpdGlvbmFsIGNhbGxiYWNrcy5cbiAqL1xuZnVuY3Rpb24gb3BlbkRCKG5hbWUsIHZlcnNpb24sIHsgYmxvY2tlZCwgdXBncmFkZSwgYmxvY2tpbmcsIHRlcm1pbmF0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIHZlcnNpb24pO1xuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKCkgPT4gYmxvY2tpbmcoKSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCIH07XG4iXSwibmFtZXMiOlsidyIsIndyYXAiLCJyIiwicmVwbGFjZVRyYXBzIiwidSIsInVud3JhcCIsIm9wZW5EQiIsIm5hbWUiLCJ2ZXJzaW9uIiwiYmxvY2tlZCIsInVwZ3JhZGUiLCJibG9ja2luZyIsInRlcm1pbmF0ZWQiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9wZW5Qcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVzdWx0Iiwib2xkVmVyc2lvbiIsIm5ld1ZlcnNpb24iLCJ0cmFuc2FjdGlvbiIsInRoZW4iLCJkYiIsImNhdGNoIiwiZGVsZXRlREIiLCJkZWxldGVEYXRhYmFzZSIsInVuZGVmaW5lZCIsInJlYWRNZXRob2RzIiwid3JpdGVNZXRob2RzIiwiY2FjaGVkTWV0aG9kcyIsIk1hcCIsImdldE1ldGhvZCIsInRhcmdldCIsInByb3AiLCJJREJEYXRhYmFzZSIsImdldCIsInRhcmdldEZ1bmNOYW1lIiwicmVwbGFjZSIsInVzZUluZGV4IiwiaXNXcml0ZSIsImluY2x1ZGVzIiwiSURCSW5kZXgiLCJJREJPYmplY3RTdG9yZSIsInByb3RvdHlwZSIsIm1ldGhvZCIsInN0b3JlTmFtZSIsImFyZ3MiLCJ0eCIsInN0b3JlIiwiaW5kZXgiLCJzaGlmdCIsIlByb21pc2UiLCJhbGwiLCJkb25lIiwic2V0Iiwib2xkVHJhcHMiLCJyZWNlaXZlciIsImhhcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/wrap-idb-value.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@firebase/installations/node_modules/idb/build/wrap-idb-value.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ reverseTransformCache; },\n/* harmony export */   i: function() { return /* binding */ instanceOfAny; },\n/* harmony export */   r: function() { return /* binding */ replaceTraps; },\n/* harmony export */   u: function() { return /* binding */ unwrap; },\n/* harmony export */   w: function() { return /* binding */ wrap; }\n/* harmony export */ });\nconst instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return idbProxyableTypes || (idbProxyableTypes = [\n        IDBDatabase,\n        IDBObjectStore,\n        IDBIndex,\n        IDBCursor,\n        IDBTransaction\n    ]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\n        IDBCursor.prototype.advance,\n        IDBCursor.prototype.continue,\n        IDBCursor.prototype.continuePrimaryKey\n    ]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            request.removeEventListener(\"success\", success);\n            request.removeEventListener(\"error\", error);\n        };\n        const success = ()=>{\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = ()=>{\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener(\"success\", success);\n        request.addEventListener(\"error\", error);\n    });\n    promise.then((value)=>{\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n    }).catch(()=>{});\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx)) return;\n    const done = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            tx.removeEventListener(\"complete\", complete);\n            tx.removeEventListener(\"error\", error);\n            tx.removeEventListener(\"abort\", error);\n        };\n        const complete = ()=>{\n            resolve();\n            unlisten();\n        };\n        const error = ()=>{\n            reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n            unlisten();\n        };\n        tx.addEventListener(\"complete\", complete);\n        tx.addEventListener(\"error\", error);\n        tx.addEventListener(\"abort\", error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get (target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === \"done\") return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === \"objectStoreNames\") {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === \"store\") {\n                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set (target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has (target, prop) {\n        if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n            return true;\n        }\n        return prop in target;\n    }\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction && !(\"objectStoreNames\" in IDBTransaction.prototype)) {\n        return function(storeNames) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [\n                storeNames\n            ]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === \"function\") return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest) return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value)) return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value)=>reverseTransformCache.get(value);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUFBTUEsZ0JBQWdCLENBQUNDLFFBQVFDLGVBQWlCQSxhQUFhQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUgsa0JBQWtCRztBQUUzRixJQUFJQztBQUNKLElBQUlDO0FBQ0oscUVBQXFFO0FBQ3JFLFNBQVNDO0lBQ0wsT0FBUUYscUJBQ0hBLENBQUFBLG9CQUFvQjtRQUNqQkc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7S0FDSDtBQUNUO0FBQ0EscUVBQXFFO0FBQ3JFLFNBQVNDO0lBQ0wsT0FBUVAsd0JBQ0hBLENBQUFBLHVCQUF1QjtRQUNwQkssVUFBVUcsU0FBUyxDQUFDQyxPQUFPO1FBQzNCSixVQUFVRyxTQUFTLENBQUNFLFFBQVE7UUFDNUJMLFVBQVVHLFNBQVMsQ0FBQ0csa0JBQWtCO0tBQ3pDO0FBQ1Q7QUFDQSxNQUFNQyxtQkFBbUIsSUFBSUM7QUFDN0IsTUFBTUMscUJBQXFCLElBQUlEO0FBQy9CLE1BQU1FLDJCQUEyQixJQUFJRjtBQUNyQyxNQUFNRyxpQkFBaUIsSUFBSUg7QUFDM0IsTUFBTUksd0JBQXdCLElBQUlKO0FBQ2xDLFNBQVNLLGlCQUFpQkMsT0FBTztJQUM3QixNQUFNQyxVQUFVLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDbEMsTUFBTUMsV0FBVztZQUNiTCxRQUFRTSxtQkFBbUIsQ0FBQyxXQUFXQztZQUN2Q1AsUUFBUU0sbUJBQW1CLENBQUMsU0FBU0U7UUFDekM7UUFDQSxNQUFNRCxVQUFVO1lBQ1pKLFFBQVFNLEtBQUtULFFBQVFVLE1BQU07WUFDM0JMO1FBQ0o7UUFDQSxNQUFNRyxRQUFRO1lBQ1ZKLE9BQU9KLFFBQVFRLEtBQUs7WUFDcEJIO1FBQ0o7UUFDQUwsUUFBUVcsZ0JBQWdCLENBQUMsV0FBV0o7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UUFDMUIvQyxzQkFBc0JnQixHQUFHLENBQUMrQixVQUFVaEM7SUFDeEM7SUFDQSxPQUFPZ0M7QUFDWDtBQUNBLE1BQU1QLFNBQVMsQ0FBQ3pCLFFBQVVmLHNCQUFzQnlCLEdBQUcsQ0FBQ1Y7QUFFaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9pbnN0YWxsYXRpb25zL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvd3JhcC1pZGItdmFsdWUuanM/NTg5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XG5cbmxldCBpZGJQcm94eWFibGVUeXBlcztcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSB7XG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxuICAgICAgICAoaWRiUHJveHlhYmxlVHlwZXMgPSBbXG4gICAgICAgICAgICBJREJEYXRhYmFzZSxcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxuICAgICAgICAgICAgSURCSW5kZXgsXG4gICAgICAgICAgICBJREJDdXJzb3IsXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcbiAgICAgICAgXSkpO1xufVxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpIHtcbiAgICByZXR1cm4gKGN1cnNvckFkdmFuY2VNZXRob2RzIHx8XG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWUsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcbiAgICAgICAgXSkpO1xufVxuY29uc3QgY3Vyc29yUmVxdWVzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBTaW5jZSBjdXJzb3JpbmcgcmV1c2VzIHRoZSBJREJSZXF1ZXN0ICgqc2lnaCopLCB3ZSBjYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgICAgIC8vIChzZWUgd3JhcEZ1bmN0aW9uKS5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCQ3Vyc29yKSB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0TWFwLnNldCh2YWx1ZSwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F0Y2hpbmcgdG8gYXZvaWQgXCJVbmNhdWdodCBQcm9taXNlIGV4Y2VwdGlvbnNcIlxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGRvZXNuJ3QgZXhpc3QgaW4gdHJhbnNmb3JtQ2FjaGUuIFRoaXNcbiAgICAvLyBpcyBiZWNhdXNlIHdlIGNyZWF0ZSBtYW55IHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdC5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb21pc2UsIHJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHR4KSB7XG4gICAgLy8gRWFybHkgYmFpbCBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgYSBkb25lIHByb21pc2UgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgaWYgKHRyYW5zYWN0aW9uRG9uZU1hcC5oYXModHgpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZG9uZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QodHguZXJyb3IgfHwgbmV3IERPTUV4Y2VwdGlvbignQWJvcnRFcnJvcicsICdBYm9ydEVycm9yJykpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICB9KTtcbiAgICAvLyBDYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgIHRyYW5zYWN0aW9uRG9uZU1hcC5zZXQodHgsIGRvbmUpO1xufVxubGV0IGlkYlByb3h5VHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0cmFuc2FjdGlvbi5kb25lLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkb25lJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Eb25lTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgLy8gUG9seWZpbGwgZm9yIG9iamVjdFN0b3JlTmFtZXMgYmVjYXVzZSBvZiBFZGdlLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdvYmplY3RTdG9yZU5hbWVzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQub2JqZWN0U3RvcmVOYW1lcyB8fCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEVkZ2UgZG9lc24ndCBzdXBwb3J0IG9iamVjdFN0b3JlTmFtZXMgKGJvb28pLCBzbyB3ZSBwb2x5ZmlsbCBpdCBoZXJlLlxuICAgIGlmIChmdW5jID09PSBJREJEYXRhYmFzZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gJiZcbiAgICAgICAgISgnb2JqZWN0U3RvcmVOYW1lcycgaW4gSURCVHJhbnNhY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlTmFtZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gZnVuYy5jYWxsKHVud3JhcCh0aGlzKSwgc3RvcmVOYW1lcywgLi4uYXJncyk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuc2V0KHR4LCBzdG9yZU5hbWVzLnNvcnQgPyBzdG9yZU5hbWVzLnNvcnQoKSA6IFtzdG9yZU5hbWVzXSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0eCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcChjdXJzb3JSZXF1ZXN0TWFwLmdldCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuZXhwb3J0IHsgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGFzIGEsIGluc3RhbmNlT2ZBbnkgYXMgaSwgcmVwbGFjZVRyYXBzIGFzIHIsIHVud3JhcCBhcyB1LCB3cmFwIGFzIHcgfTtcbiJdLCJuYW1lcyI6WyJpbnN0YW5jZU9mQW55Iiwib2JqZWN0IiwiY29uc3RydWN0b3JzIiwic29tZSIsImMiLCJpZGJQcm94eWFibGVUeXBlcyIsImN1cnNvckFkdmFuY2VNZXRob2RzIiwiZ2V0SWRiUHJveHlhYmxlVHlwZXMiLCJJREJEYXRhYmFzZSIsIklEQk9iamVjdFN0b3JlIiwiSURCSW5kZXgiLCJJREJDdXJzb3IiLCJJREJUcmFuc2FjdGlvbiIsImdldEN1cnNvckFkdmFuY2VNZXRob2RzIiwicHJvdG90eXBlIiwiYWR2YW5jZSIsImNvbnRpbnVlIiwiY29udGludWVQcmltYXJ5S2V5IiwiY3Vyc29yUmVxdWVzdE1hcCIsIldlYWtNYXAiLCJ0cmFuc2FjdGlvbkRvbmVNYXAiLCJ0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAiLCJ0cmFuc2Zvcm1DYWNoZSIsInJldmVyc2VUcmFuc2Zvcm1DYWNoZSIsInByb21pc2lmeVJlcXVlc3QiLCJyZXF1ZXN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidW5saXN0ZW4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3VjY2VzcyIsImVycm9yIiwid3JhcCIsInJlc3VsdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0aGVuIiwidmFsdWUiLCJzZXQiLCJjYXRjaCIsImNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbiIsInR4IiwiaGFzIiwiZG9uZSIsImNvbXBsZXRlIiwiRE9NRXhjZXB0aW9uIiwiaWRiUHJveHlUcmFwcyIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIm9iamVjdFN0b3JlTmFtZXMiLCJ1bmRlZmluZWQiLCJvYmplY3RTdG9yZSIsInJlcGxhY2VUcmFwcyIsImNhbGxiYWNrIiwid3JhcEZ1bmN0aW9uIiwiZnVuYyIsInRyYW5zYWN0aW9uIiwic3RvcmVOYW1lcyIsImFyZ3MiLCJjYWxsIiwidW53cmFwIiwic29ydCIsImluY2x1ZGVzIiwiYXBwbHkiLCJ0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlIiwiUHJveHkiLCJJREJSZXF1ZXN0IiwibmV3VmFsdWUiLCJhIiwiaSIsInIiLCJ1IiwidyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/installations/node_modules/idb/build/wrap-idb-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/messaging/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/messaging/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteToken: function() { return /* binding */ deleteToken; },\n/* harmony export */   getMessaging: function() { return /* binding */ getMessagingInWindow; },\n/* harmony export */   getToken: function() { return /* binding */ getToken; },\n/* harmony export */   isSupported: function() { return /* binding */ isWindowSupported; },\n/* harmony export */   onMessage: function() { return /* binding */ onMessage; }\n/* harmony export */ });\n/* harmony import */ var _firebase_installations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/installations */ \"(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(app-pages-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/index.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ \"(app-pages-browser)/./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/app */ \"(app-pages-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_SW_PATH = \"/firebase-messaging-sw.js\";\nconst DEFAULT_SW_SCOPE = \"/firebase-cloud-messaging-push-scope\";\nconst DEFAULT_VAPID_KEY = \"BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4\";\nconst ENDPOINT = \"https://fcmregistrations.googleapis.com/v1\";\nconst CONSOLE_CAMPAIGN_ID = \"google.c.a.c_id\";\nconst CONSOLE_CAMPAIGN_NAME = \"google.c.a.c_l\";\nconst CONSOLE_CAMPAIGN_TIME = \"google.c.a.ts\";\n/** Set to '1' if Analytics is enabled for the campaign */ const CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = \"google.c.a.e\";\nvar MessageType$1;\n(function(MessageType) {\n    MessageType[MessageType[\"DATA_MESSAGE\"] = 1] = \"DATA_MESSAGE\";\n    MessageType[MessageType[\"DISPLAY_NOTIFICATION\"] = 3] = \"DISPLAY_NOTIFICATION\";\n})(MessageType$1 || (MessageType$1 = {}));\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\r\n * in compliance with the License. You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n * or implied. See the License for the specific language governing permissions and limitations under\r\n * the License.\r\n */ var MessageType;\n(function(MessageType) {\n    MessageType[\"PUSH_RECEIVED\"] = \"push-received\";\n    MessageType[\"NOTIFICATION_CLICKED\"] = \"notification-clicked\";\n})(MessageType || (MessageType = {}));\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function arrayToBase64(array) {\n    const uint8Array = new Uint8Array(array);\n    const base64String = btoa(String.fromCharCode(...uint8Array));\n    return base64String.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64ToArray(base64String) {\n    const padding = \"=\".repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n    const rawData = atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n    for(let i = 0; i < rawData.length; ++i){\n        outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const OLD_DB_NAME = \"fcm_token_details_db\";\n/**\r\n * The last DB version of 'fcm_token_details_db' was 4. This is one higher, so that the upgrade\r\n * callback is called for all versions of the old DB.\r\n */ const OLD_DB_VERSION = 5;\nconst OLD_OBJECT_STORE_NAME = \"fcm_token_object_Store\";\nasync function migrateOldDatabase(senderId) {\n    if (\"databases\" in indexedDB) {\n        // indexedDb.databases() is an IndexedDB v3 API and does not exist in all browsers. TODO: Remove\n        // typecast when it lands in TS types.\n        const databases = await indexedDB.databases();\n        const dbNames = databases.map((db)=>db.name);\n        if (!dbNames.includes(OLD_DB_NAME)) {\n            // old DB didn't exist, no need to open.\n            return null;\n        }\n    }\n    let tokenDetails = null;\n    const db = await (0,idb__WEBPACK_IMPORTED_MODULE_2__.openDB)(OLD_DB_NAME, OLD_DB_VERSION, {\n        upgrade: async (db, oldVersion, newVersion, upgradeTransaction)=>{\n            var _a;\n            if (oldVersion < 2) {\n                // Database too old, skip migration.\n                return;\n            }\n            if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n                // Database did not exist. Nothing to do.\n                return;\n            }\n            const objectStore = upgradeTransaction.objectStore(OLD_OBJECT_STORE_NAME);\n            const value = await objectStore.index(\"fcmSenderId\").get(senderId);\n            await objectStore.clear();\n            if (!value) {\n                // No entry in the database, nothing to migrate.\n                return;\n            }\n            if (oldVersion === 2) {\n                const oldDetails = value;\n                if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {\n                    return;\n                }\n                tokenDetails = {\n                    token: oldDetails.fcmToken,\n                    createTime: (_a = oldDetails.createTime) !== null && _a !== void 0 ? _a : Date.now(),\n                    subscriptionOptions: {\n                        auth: oldDetails.auth,\n                        p256dh: oldDetails.p256dh,\n                        endpoint: oldDetails.endpoint,\n                        swScope: oldDetails.swScope,\n                        vapidKey: typeof oldDetails.vapidKey === \"string\" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)\n                    }\n                };\n            } else if (oldVersion === 3) {\n                const oldDetails = value;\n                tokenDetails = {\n                    token: oldDetails.fcmToken,\n                    createTime: oldDetails.createTime,\n                    subscriptionOptions: {\n                        auth: arrayToBase64(oldDetails.auth),\n                        p256dh: arrayToBase64(oldDetails.p256dh),\n                        endpoint: oldDetails.endpoint,\n                        swScope: oldDetails.swScope,\n                        vapidKey: arrayToBase64(oldDetails.vapidKey)\n                    }\n                };\n            } else if (oldVersion === 4) {\n                const oldDetails = value;\n                tokenDetails = {\n                    token: oldDetails.fcmToken,\n                    createTime: oldDetails.createTime,\n                    subscriptionOptions: {\n                        auth: arrayToBase64(oldDetails.auth),\n                        p256dh: arrayToBase64(oldDetails.p256dh),\n                        endpoint: oldDetails.endpoint,\n                        swScope: oldDetails.swScope,\n                        vapidKey: arrayToBase64(oldDetails.vapidKey)\n                    }\n                };\n            }\n        }\n    });\n    db.close();\n    // Delete all old databases.\n    await (0,idb__WEBPACK_IMPORTED_MODULE_2__.deleteDB)(OLD_DB_NAME);\n    await (0,idb__WEBPACK_IMPORTED_MODULE_2__.deleteDB)(\"fcm_vapid_details_db\");\n    await (0,idb__WEBPACK_IMPORTED_MODULE_2__.deleteDB)(\"undefined\");\n    return checkTokenDetails(tokenDetails) ? tokenDetails : null;\n}\nfunction checkTokenDetails(tokenDetails) {\n    if (!tokenDetails || !tokenDetails.subscriptionOptions) {\n        return false;\n    }\n    const { subscriptionOptions } = tokenDetails;\n    return typeof tokenDetails.createTime === \"number\" && tokenDetails.createTime > 0 && typeof tokenDetails.token === \"string\" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === \"string\" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === \"string\" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === \"string\" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === \"string\" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === \"string\" && subscriptionOptions.vapidKey.length > 0;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Exported for tests.\nconst DATABASE_NAME = \"firebase-messaging-database\";\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = \"firebase-messaging-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_2__.openDB)(DATABASE_NAME, DATABASE_VERSION, {\n            upgrade: (upgradeDb, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through behavior is what we want,\n                // because if there are multiple versions between the old version and the current version, we\n                // want ALL the migrations that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        upgradeDb.createObjectStore(OBJECT_STORE_NAME);\n                }\n            }\n        });\n    }\n    return dbPromise;\n}\n/** Gets record(s) from the objectStore that match the given key. */ async function dbGet(firebaseDependencies) {\n    const key = getKey(firebaseDependencies);\n    const db = await getDbPromise();\n    const tokenDetails = await db.transaction(OBJECT_STORE_NAME).objectStore(OBJECT_STORE_NAME).get(key);\n    if (tokenDetails) {\n        return tokenDetails;\n    } else {\n        // Check if there is a tokenDetails object in the old DB.\n        const oldTokenDetails = await migrateOldDatabase(firebaseDependencies.appConfig.senderId);\n        if (oldTokenDetails) {\n            await dbSet(firebaseDependencies, oldTokenDetails);\n            return oldTokenDetails;\n        }\n    }\n}\n/** Assigns or overwrites the record for the given key with the given value. */ async function dbSet(firebaseDependencies, tokenDetails) {\n    const key = getKey(firebaseDependencies);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    await tx.objectStore(OBJECT_STORE_NAME).put(tokenDetails, key);\n    await tx.done;\n    return tokenDetails;\n}\n/** Removes record(s) from the objectStore that match the given key. */ async function dbRemove(firebaseDependencies) {\n    const key = getKey(firebaseDependencies);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n    await tx.done;\n}\nfunction getKey(param) {\n    let { appConfig } = param;\n    return appConfig.appId;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERROR_MAP = {\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ ]: 'Missing App configuration value: \"{$valueName}\"',\n    [\"only-available-in-window\" /* ErrorCode.AVAILABLE_IN_WINDOW */ ]: \"This method is available in a Window context.\",\n    [\"only-available-in-sw\" /* ErrorCode.AVAILABLE_IN_SW */ ]: \"This method is available in a service worker context.\",\n    [\"permission-default\" /* ErrorCode.PERMISSION_DEFAULT */ ]: \"The notification permission was not granted and dismissed instead.\",\n    [\"permission-blocked\" /* ErrorCode.PERMISSION_BLOCKED */ ]: \"The notification permission was not granted and blocked instead.\",\n    [\"unsupported-browser\" /* ErrorCode.UNSUPPORTED_BROWSER */ ]: \"This browser doesn't support the API's required to use the Firebase SDK.\",\n    [\"indexed-db-unsupported\" /* ErrorCode.INDEXED_DB_UNSUPPORTED */ ]: \"This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)\",\n    [\"failed-service-worker-registration\" /* ErrorCode.FAILED_DEFAULT_REGISTRATION */ ]: \"We are unable to register the default service worker. {$browserErrorMessage}\",\n    [\"token-subscribe-failed\" /* ErrorCode.TOKEN_SUBSCRIBE_FAILED */ ]: \"A problem occurred while subscribing the user to FCM: {$errorInfo}\",\n    [\"token-subscribe-no-token\" /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */ ]: \"FCM returned no token when subscribing the user to push.\",\n    [\"token-unsubscribe-failed\" /* ErrorCode.TOKEN_UNSUBSCRIBE_FAILED */ ]: \"A problem occurred while unsubscribing the \" + \"user from FCM: {$errorInfo}\",\n    [\"token-update-failed\" /* ErrorCode.TOKEN_UPDATE_FAILED */ ]: \"A problem occurred while updating the user from FCM: {$errorInfo}\",\n    [\"token-update-no-token\" /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */ ]: \"FCM returned no token when updating the user to push.\",\n    [\"use-sw-after-get-token\" /* ErrorCode.USE_SW_AFTER_GET_TOKEN */ ]: \"The useServiceWorker() method may only be called once and must be \" + \"called before calling getToken() to ensure your service worker is used.\",\n    [\"invalid-sw-registration\" /* ErrorCode.INVALID_SW_REGISTRATION */ ]: \"The input to useServiceWorker() must be a ServiceWorkerRegistration.\",\n    [\"invalid-bg-handler\" /* ErrorCode.INVALID_BG_HANDLER */ ]: \"The input to setBackgroundMessageHandler() must be a function.\",\n    [\"invalid-vapid-key\" /* ErrorCode.INVALID_VAPID_KEY */ ]: \"The public VAPID key must be a string.\",\n    [\"use-vapid-key-after-get-token\" /* ErrorCode.USE_VAPID_KEY_AFTER_GET_TOKEN */ ]: \"The usePublicVapidKey() method may only be called once and must be \" + \"called before calling getToken() to ensure your VAPID key is used.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_3__.ErrorFactory(\"messaging\", \"Messaging\", ERROR_MAP);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function requestGetToken(firebaseDependencies, subscriptionOptions) {\n    const headers = await getHeaders(firebaseDependencies);\n    const body = getBody(subscriptionOptions);\n    const subscribeOptions = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    let responseData;\n    try {\n        const response = await fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions);\n        responseData = await response.json();\n    } catch (err) {\n        throw ERROR_FACTORY.create(\"token-subscribe-failed\" /* ErrorCode.TOKEN_SUBSCRIBE_FAILED */ , {\n            errorInfo: err === null || err === void 0 ? void 0 : err.toString()\n        });\n    }\n    if (responseData.error) {\n        const message = responseData.error.message;\n        throw ERROR_FACTORY.create(\"token-subscribe-failed\" /* ErrorCode.TOKEN_SUBSCRIBE_FAILED */ , {\n            errorInfo: message\n        });\n    }\n    if (!responseData.token) {\n        throw ERROR_FACTORY.create(\"token-subscribe-no-token\" /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */ );\n    }\n    return responseData.token;\n}\nasync function requestUpdateToken(firebaseDependencies, tokenDetails) {\n    const headers = await getHeaders(firebaseDependencies);\n    const body = getBody(tokenDetails.subscriptionOptions);\n    const updateOptions = {\n        method: \"PATCH\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    let responseData;\n    try {\n        const response = await fetch(\"\".concat(getEndpoint(firebaseDependencies.appConfig), \"/\").concat(tokenDetails.token), updateOptions);\n        responseData = await response.json();\n    } catch (err) {\n        throw ERROR_FACTORY.create(\"token-update-failed\" /* ErrorCode.TOKEN_UPDATE_FAILED */ , {\n            errorInfo: err === null || err === void 0 ? void 0 : err.toString()\n        });\n    }\n    if (responseData.error) {\n        const message = responseData.error.message;\n        throw ERROR_FACTORY.create(\"token-update-failed\" /* ErrorCode.TOKEN_UPDATE_FAILED */ , {\n            errorInfo: message\n        });\n    }\n    if (!responseData.token) {\n        throw ERROR_FACTORY.create(\"token-update-no-token\" /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */ );\n    }\n    return responseData.token;\n}\nasync function requestDeleteToken(firebaseDependencies, token) {\n    const headers = await getHeaders(firebaseDependencies);\n    const unsubscribeOptions = {\n        method: \"DELETE\",\n        headers\n    };\n    try {\n        const response = await fetch(\"\".concat(getEndpoint(firebaseDependencies.appConfig), \"/\").concat(token), unsubscribeOptions);\n        const responseData = await response.json();\n        if (responseData.error) {\n            const message = responseData.error.message;\n            throw ERROR_FACTORY.create(\"token-unsubscribe-failed\" /* ErrorCode.TOKEN_UNSUBSCRIBE_FAILED */ , {\n                errorInfo: message\n            });\n        }\n    } catch (err) {\n        throw ERROR_FACTORY.create(\"token-unsubscribe-failed\" /* ErrorCode.TOKEN_UNSUBSCRIBE_FAILED */ , {\n            errorInfo: err === null || err === void 0 ? void 0 : err.toString()\n        });\n    }\n}\nfunction getEndpoint(param) {\n    let { projectId } = param;\n    return \"\".concat(ENDPOINT, \"/projects/\").concat(projectId, \"/registrations\");\n}\nasync function getHeaders(param) {\n    let { appConfig, installations } = param;\n    const authToken = await installations.getToken();\n    return new Headers({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        \"x-goog-api-key\": appConfig.apiKey,\n        \"x-goog-firebase-installations-auth\": \"FIS \".concat(authToken)\n    });\n}\nfunction getBody(param) {\n    let { p256dh, auth, endpoint, vapidKey } = param;\n    const body = {\n        web: {\n            endpoint,\n            auth,\n            p256dh\n        }\n    };\n    if (vapidKey !== DEFAULT_VAPID_KEY) {\n        body.web.applicationPubKey = vapidKey;\n    }\n    return body;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // UpdateRegistration will be called once every week.\nconst TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\nasync function getTokenInternal(messaging) {\n    const pushSubscription = await getPushSubscription(messaging.swRegistration, messaging.vapidKey);\n    const subscriptionOptions = {\n        vapidKey: messaging.vapidKey,\n        swScope: messaging.swRegistration.scope,\n        endpoint: pushSubscription.endpoint,\n        auth: arrayToBase64(pushSubscription.getKey(\"auth\")),\n        p256dh: arrayToBase64(pushSubscription.getKey(\"p256dh\"))\n    };\n    const tokenDetails = await dbGet(messaging.firebaseDependencies);\n    if (!tokenDetails) {\n        // No token, get a new one.\n        return getNewToken(messaging.firebaseDependencies, subscriptionOptions);\n    } else if (!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) {\n        // Invalid token, get a new one.\n        try {\n            await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);\n        } catch (e) {\n            // Suppress errors because of #2364\n            console.warn(e);\n        }\n        return getNewToken(messaging.firebaseDependencies, subscriptionOptions);\n    } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {\n        // Weekly token refresh\n        return updateToken(messaging, {\n            token: tokenDetails.token,\n            createTime: Date.now(),\n            subscriptionOptions\n        });\n    } else {\n        // Valid token, nothing to do.\n        return tokenDetails.token;\n    }\n}\n/**\r\n * This method deletes the token from the database, unsubscribes the token from FCM, and unregisters\r\n * the push subscription if it exists.\r\n */ async function deleteTokenInternal(messaging) {\n    const tokenDetails = await dbGet(messaging.firebaseDependencies);\n    if (tokenDetails) {\n        await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);\n        await dbRemove(messaging.firebaseDependencies);\n    }\n    // Unsubscribe from the push subscription.\n    const pushSubscription = await messaging.swRegistration.pushManager.getSubscription();\n    if (pushSubscription) {\n        return pushSubscription.unsubscribe();\n    }\n    // If there's no SW, consider it a success.\n    return true;\n}\nasync function updateToken(messaging, tokenDetails) {\n    try {\n        const updatedToken = await requestUpdateToken(messaging.firebaseDependencies, tokenDetails);\n        const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), {\n            token: updatedToken,\n            createTime: Date.now()\n        });\n        await dbSet(messaging.firebaseDependencies, updatedTokenDetails);\n        return updatedToken;\n    } catch (e) {\n        await deleteTokenInternal(messaging);\n        throw e;\n    }\n}\nasync function getNewToken(firebaseDependencies, subscriptionOptions) {\n    const token = await requestGetToken(firebaseDependencies, subscriptionOptions);\n    const tokenDetails = {\n        token,\n        createTime: Date.now(),\n        subscriptionOptions\n    };\n    await dbSet(firebaseDependencies, tokenDetails);\n    return tokenDetails.token;\n}\n/**\r\n * Gets a PushSubscription for the current user.\r\n */ async function getPushSubscription(swRegistration, vapidKey) {\n    const subscription = await swRegistration.pushManager.getSubscription();\n    if (subscription) {\n        return subscription;\n    }\n    return swRegistration.pushManager.subscribe({\n        userVisibleOnly: true,\n        // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key\n        // submitted to pushManager#subscribe must be of type Uint8Array.\n        applicationServerKey: base64ToArray(vapidKey)\n    });\n}\n/**\r\n * Checks if the saved tokenDetails object matches the configuration provided.\r\n */ function isTokenValid(dbOptions, currentOptions) {\n    const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;\n    const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;\n    const isAuthEqual = currentOptions.auth === dbOptions.auth;\n    const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;\n    return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function externalizePayload(internalPayload) {\n    const payload = {\n        from: internalPayload.from,\n        // eslint-disable-next-line camelcase\n        collapseKey: internalPayload.collapse_key,\n        // eslint-disable-next-line camelcase\n        messageId: internalPayload.fcmMessageId\n    };\n    propagateNotificationPayload(payload, internalPayload);\n    propagateDataPayload(payload, internalPayload);\n    propagateFcmOptions(payload, internalPayload);\n    return payload;\n}\nfunction propagateNotificationPayload(payload, messagePayloadInternal) {\n    if (!messagePayloadInternal.notification) {\n        return;\n    }\n    payload.notification = {};\n    const title = messagePayloadInternal.notification.title;\n    if (!!title) {\n        payload.notification.title = title;\n    }\n    const body = messagePayloadInternal.notification.body;\n    if (!!body) {\n        payload.notification.body = body;\n    }\n    const image = messagePayloadInternal.notification.image;\n    if (!!image) {\n        payload.notification.image = image;\n    }\n    const icon = messagePayloadInternal.notification.icon;\n    if (!!icon) {\n        payload.notification.icon = icon;\n    }\n}\nfunction propagateDataPayload(payload, messagePayloadInternal) {\n    if (!messagePayloadInternal.data) {\n        return;\n    }\n    payload.data = messagePayloadInternal.data;\n}\nfunction propagateFcmOptions(payload, messagePayloadInternal) {\n    var _a, _b, _c, _d, _e;\n    // fcmOptions.link value is written into notification.click_action. see more in b/232072111\n    if (!messagePayloadInternal.fcmOptions && !((_a = messagePayloadInternal.notification) === null || _a === void 0 ? void 0 : _a.click_action)) {\n        return;\n    }\n    payload.fcmOptions = {};\n    const link = (_c = (_b = messagePayloadInternal.fcmOptions) === null || _b === void 0 ? void 0 : _b.link) !== null && _c !== void 0 ? _c : (_d = messagePayloadInternal.notification) === null || _d === void 0 ? void 0 : _d.click_action;\n    if (!!link) {\n        payload.fcmOptions.link = link;\n    }\n    // eslint-disable-next-line camelcase\n    const analyticsLabel = (_e = messagePayloadInternal.fcmOptions) === null || _e === void 0 ? void 0 : _e.analytics_label;\n    if (!!analyticsLabel) {\n        payload.fcmOptions.analyticsLabel = analyticsLabel;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function isConsoleMessage(data) {\n    // This message has a campaign ID, meaning it was sent using the Firebase Console.\n    return typeof data === \"object\" && !!data && CONSOLE_CAMPAIGN_ID in data;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ _mergeStrings(\"hts/frbslgigp.ogepscmv/ieo/eaylg\", \"tp:/ieaeogn-agolai.o/1frlglgc/o\");\n_mergeStrings(\"AzSCbw63g1R0nCw85jG8\", \"Iaya3yLKwmgvh7cF0q4\");\nfunction _mergeStrings(s1, s2) {\n    const resultArray = [];\n    for(let i = 0; i < s1.length; i++){\n        resultArray.push(s1.charAt(i));\n        if (i < s2.length) {\n            resultArray.push(s2.charAt(i));\n        }\n    }\n    return resultArray.join(\"\");\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function extractAppConfig(app) {\n    if (!app || !app.options) {\n        throw getMissingValueError(\"App Configuration Object\");\n    }\n    if (!app.name) {\n        throw getMissingValueError(\"App Name\");\n    }\n    // Required app config keys\n    const configKeys = [\n        \"projectId\",\n        \"apiKey\",\n        \"appId\",\n        \"messagingSenderId\"\n    ];\n    const { options } = app;\n    for (const keyName of configKeys){\n        if (!options[keyName]) {\n            throw getMissingValueError(keyName);\n        }\n    }\n    return {\n        appName: app.name,\n        projectId: options.projectId,\n        apiKey: options.apiKey,\n        appId: options.appId,\n        senderId: options.messagingSenderId\n    };\n}\nfunction getMissingValueError(valueName) {\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ , {\n        valueName\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MessagingService {\n    _delete() {\n        return Promise.resolve();\n    }\n    constructor(app, installations, analyticsProvider){\n        // logging is only done with end user consent. Default to false.\n        this.deliveryMetricsExportedToBigQueryEnabled = false;\n        this.onBackgroundMessageHandler = null;\n        this.onMessageHandler = null;\n        this.logEvents = [];\n        this.isLogServiceStarted = false;\n        const appConfig = extractAppConfig(app);\n        this.firebaseDependencies = {\n            app,\n            appConfig,\n            installations,\n            analyticsProvider\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function registerDefaultSw(messaging) {\n    try {\n        messaging.swRegistration = await navigator.serviceWorker.register(DEFAULT_SW_PATH, {\n            scope: DEFAULT_SW_SCOPE\n        });\n        // The timing when browser updates sw when sw has an update is unreliable from experiment. It\n        // leads to version conflict when the SDK upgrades to a newer version in the main page, but sw\n        // is stuck with the old version. For example,\n        // https://github.com/firebase/firebase-js-sdk/issues/2590 The following line reliably updates\n        // sw if there was an update.\n        messaging.swRegistration.update().catch(()=>{\n        /* it is non blocking and we don't care if it failed */ });\n    } catch (e) {\n        throw ERROR_FACTORY.create(\"failed-service-worker-registration\" /* ErrorCode.FAILED_DEFAULT_REGISTRATION */ , {\n            browserErrorMessage: e === null || e === void 0 ? void 0 : e.message\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function updateSwReg(messaging, swRegistration) {\n    if (!swRegistration && !messaging.swRegistration) {\n        await registerDefaultSw(messaging);\n    }\n    if (!swRegistration && !!messaging.swRegistration) {\n        return;\n    }\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n        throw ERROR_FACTORY.create(\"invalid-sw-registration\" /* ErrorCode.INVALID_SW_REGISTRATION */ );\n    }\n    messaging.swRegistration = swRegistration;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function updateVapidKey(messaging, vapidKey) {\n    if (!!vapidKey) {\n        messaging.vapidKey = vapidKey;\n    } else if (!messaging.vapidKey) {\n        messaging.vapidKey = DEFAULT_VAPID_KEY;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function getToken$1(messaging, options) {\n    if (!navigator) {\n        throw ERROR_FACTORY.create(\"only-available-in-window\" /* ErrorCode.AVAILABLE_IN_WINDOW */ );\n    }\n    if (Notification.permission === \"default\") {\n        await Notification.requestPermission();\n    }\n    if (Notification.permission !== \"granted\") {\n        throw ERROR_FACTORY.create(\"permission-blocked\" /* ErrorCode.PERMISSION_BLOCKED */ );\n    }\n    await updateVapidKey(messaging, options === null || options === void 0 ? void 0 : options.vapidKey);\n    await updateSwReg(messaging, options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration);\n    return getTokenInternal(messaging);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function logToScion(messaging, messageType, data) {\n    const eventType = getEventType(messageType);\n    const analytics = await messaging.firebaseDependencies.analyticsProvider.get();\n    analytics.logEvent(eventType, {\n        /* eslint-disable camelcase */ message_id: data[CONSOLE_CAMPAIGN_ID],\n        message_name: data[CONSOLE_CAMPAIGN_NAME],\n        message_time: data[CONSOLE_CAMPAIGN_TIME],\n        message_device_time: Math.floor(Date.now() / 1000)\n    });\n}\nfunction getEventType(messageType) {\n    switch(messageType){\n        case MessageType.NOTIFICATION_CLICKED:\n            return \"notification_open\";\n        case MessageType.PUSH_RECEIVED:\n            return \"notification_foreground\";\n        default:\n            throw new Error();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function messageEventListener(messaging, event) {\n    const internalPayload = event.data;\n    if (!internalPayload.isFirebaseMessaging) {\n        return;\n    }\n    if (messaging.onMessageHandler && internalPayload.messageType === MessageType.PUSH_RECEIVED) {\n        if (typeof messaging.onMessageHandler === \"function\") {\n            messaging.onMessageHandler(externalizePayload(internalPayload));\n        } else {\n            messaging.onMessageHandler.next(externalizePayload(internalPayload));\n        }\n    }\n    // Log to Scion if applicable\n    const dataPayload = internalPayload.data;\n    if (isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === \"1\") {\n        await logToScion(messaging, internalPayload.messageType, dataPayload);\n    }\n}\nconst name = \"@firebase/messaging\";\nconst version = \"0.12.4\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const WindowMessagingFactory = (container)=>{\n    const messaging = new MessagingService(container.getProvider(\"app\").getImmediate(), container.getProvider(\"installations-internal\").getImmediate(), container.getProvider(\"analytics-internal\"));\n    navigator.serviceWorker.addEventListener(\"message\", (e)=>messageEventListener(messaging, e));\n    return messaging;\n};\n_c = WindowMessagingFactory;\nconst WindowMessagingInternalFactory = (container)=>{\n    const messaging = container.getProvider(\"messaging\").getImmediate();\n    const messagingInternal = {\n        getToken: (options)=>getToken$1(messaging, options)\n    };\n    return messagingInternal;\n};\n_c1 = WindowMessagingInternalFactory;\nfunction registerMessagingInWindow() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"messaging\", WindowMessagingFactory, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"messaging-internal\", WindowMessagingInternalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__.registerVersion)(name, version);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Checks if all required APIs exist in the browser.\r\n * @returns a Promise that resolves to a boolean.\r\n *\r\n * @public\r\n */ async function isWindowSupported() {\n    try {\n        // This throws if open() is unsupported, so adding it to the conditional\n        // statement below can cause an uncaught error.\n        await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateIndexedDBOpenable)();\n    } catch (e) {\n        return false;\n    }\n    // firebase-js-sdk/issues/2393 reveals that idb#open in Safari iframe and Firefox private browsing\n    // might be prohibited to run. In these contexts, an error would be thrown during the messaging\n    // instantiating phase, informing the developers to import/call isSupported for special handling.\n    return  true && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)() && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.areCookiesEnabled)() && \"serviceWorker\" in navigator && \"PushManager\" in window && \"Notification\" in window && \"fetch\" in window && ServiceWorkerRegistration.prototype.hasOwnProperty(\"showNotification\") && PushSubscription.prototype.hasOwnProperty(\"getKey\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function deleteToken$1(messaging) {\n    if (!navigator) {\n        throw ERROR_FACTORY.create(\"only-available-in-window\" /* ErrorCode.AVAILABLE_IN_WINDOW */ );\n    }\n    if (!messaging.swRegistration) {\n        await registerDefaultSw(messaging);\n    }\n    return deleteTokenInternal(messaging);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function onMessage$1(messaging, nextOrObserver) {\n    if (!navigator) {\n        throw ERROR_FACTORY.create(\"only-available-in-window\" /* ErrorCode.AVAILABLE_IN_WINDOW */ );\n    }\n    messaging.onMessageHandler = nextOrObserver;\n    return ()=>{\n        messaging.onMessageHandler = null;\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Retrieves a Firebase Cloud Messaging instance.\r\n *\r\n * @returns The Firebase Cloud Messaging instance associated with the provided firebase app.\r\n *\r\n * @public\r\n */ function getMessagingInWindow() {\n    let app = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__.getApp)();\n    // Conscious decision to make this async check non-blocking during the messaging instance\n    // initialization phase for performance consideration. An error would be thrown latter for\n    // developer's information. Developers can then choose to import and call `isSupported` for\n    // special handling.\n    isWindowSupported().then((isSupported)=>{\n        // If `isWindowSupported()` resolved, but returned false.\n        if (!isSupported) {\n            throw ERROR_FACTORY.create(\"unsupported-browser\" /* ErrorCode.UNSUPPORTED_BROWSER */ );\n        }\n    }, (_)=>{\n        // If `isWindowSupported()` rejected.\n        throw ERROR_FACTORY.create(\"indexed-db-unsupported\" /* ErrorCode.INDEXED_DB_UNSUPPORTED */ );\n    });\n    return (0,_firebase_app__WEBPACK_IMPORTED_MODULE_4__._getProvider)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(app), \"messaging\").getImmediate();\n}\n/**\r\n * Subscribes the {@link Messaging} instance to push notifications. Returns an Firebase Cloud\r\n * Messaging registration token that can be used to send push messages to that {@link Messaging}\r\n * instance.\r\n *\r\n * If a notification permission isn't already granted, this method asks the user for permission. The\r\n * returned promise rejects if the user does not allow the app to show notifications.\r\n *\r\n * @param messaging - The {@link Messaging} instance.\r\n * @param options - Provides an optional vapid key and an optinoal service worker registration\r\n *\r\n * @returns The promise resolves with an FCM registration token.\r\n *\r\n * @public\r\n */ async function getToken(messaging, options) {\n    messaging = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(messaging);\n    return getToken$1(messaging, options);\n}\n/**\r\n * Deletes the registration token associated with this {@link Messaging} instance and unsubscribes\r\n * the {@link Messaging} instance from the push subscription.\r\n *\r\n * @param messaging - The {@link Messaging} instance.\r\n *\r\n * @returns The promise resolves when the token has been successfully deleted.\r\n *\r\n * @public\r\n */ function deleteToken(messaging) {\n    messaging = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(messaging);\n    return deleteToken$1(messaging);\n}\n/**\r\n * When a push message is received and the user is currently on a page for your origin, the\r\n * message is passed to the page and an `onMessage()` event is dispatched with the payload of\r\n * the push message.\r\n *\r\n *\r\n * @param messaging - The {@link Messaging} instance.\r\n * @param nextOrObserver - This function, or observer object with `next` defined,\r\n *     is called when a message is received and the user is currently viewing your page.\r\n * @returns To stop listening for messages execute this returned function.\r\n *\r\n * @public\r\n */ function onMessage(messaging, nextOrObserver) {\n    messaging = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(messaging);\n    return onMessage$1(messaging, nextOrObserver);\n}\n/**\r\n * Firebase Cloud Messaging\r\n *\r\n * @packageDocumentation\r\n */ registerMessagingInWindow();\n //# sourceMappingURL=index.esm2017.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"WindowMessagingFactory\");\n$RefreshReg$(_c1, \"WindowMessagingInternalFactory\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNlO0FBQ1Q7QUFDK0Y7QUFDNUM7QUFFMUY7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTVksa0JBQWtCO0FBQ3hCLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3QjtBQUM5Qix3REFBd0QsR0FDeEQsTUFBTUMscUNBQXFDO0FBQzNDLElBQUlDO0FBQ0gsVUFBVUMsV0FBVztJQUNsQkEsV0FBVyxDQUFDQSxXQUFXLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMvQ0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsdUJBQXVCLEdBQUcsRUFBRSxHQUFHO0FBQzNELEdBQUdELGlCQUFrQkEsQ0FBQUEsZ0JBQWdCLENBQUM7QUFFdEM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFDLGdCQUFnQixHQUFHO0lBQy9CQSxXQUFXLENBQUMsdUJBQXVCLEdBQUc7QUFDMUMsR0FBR0EsZUFBZ0JBLENBQUFBLGNBQWMsQ0FBQztBQUVsQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxTQUFTQyxjQUFjQyxLQUFLO0lBQ3hCLE1BQU1DLGFBQWEsSUFBSUMsV0FBV0Y7SUFDbEMsTUFBTUcsZUFBZUMsS0FBS0MsT0FBT0MsWUFBWSxJQUFJTDtJQUNqRCxPQUFPRSxhQUFhSSxPQUFPLENBQUMsTUFBTSxJQUFJQSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsT0FBTztBQUM3RTtBQUNBLFNBQVNDLGNBQWNMLFlBQVk7SUFDL0IsTUFBTU0sVUFBVSxJQUFJQyxNQUFNLENB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QixPQUFPNkYsV0FBVzdGLFdBQVdpRTtBQUNqQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVMwRSxZQUFZM0ksU0FBUztJQUMxQkEsWUFBWW5JLGtFQUFrQkEsQ0FBQ21JO0lBQy9CLE9BQU9vSSxjQUFjcEk7QUFDekI7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTNEksVUFBVTVJLFNBQVMsRUFBRXNJLGNBQWM7SUFDeEN0SSxZQUFZbkksa0VBQWtCQSxDQUFDbUk7SUFDL0IsT0FBT3FJLFlBQVlySSxXQUFXc0k7QUFDbEM7QUFFQTs7OztDQUlDLEdBQ0RSO0FBRW9ILENBQ3BILHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzUyMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IG9wZW5EQiwgZGVsZXRlREIgfSBmcm9tICdpZGInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgYXJlQ29va2llc0VuYWJsZWQsIGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBfZ2V0UHJvdmlkZXIsIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX1NXX1BBVEggPSAnL2ZpcmViYXNlLW1lc3NhZ2luZy1zdy5qcyc7XHJcbmNvbnN0IERFRkFVTFRfU1dfU0NPUEUgPSAnL2ZpcmViYXNlLWNsb3VkLW1lc3NhZ2luZy1wdXNoLXNjb3BlJztcclxuY29uc3QgREVGQVVMVF9WQVBJRF9LRVkgPSAnQkRPVTk5LWg2N0hjQTZKZUZYSGJTTk11N2UyeU5OdTNSem9NajhUTTRXODhqSVRmcTdabVB2SU0xSXYtNF9sMkx4UWNZd2hxYnkyeEdwV3d6amZBbkc0JztcclxuY29uc3QgRU5EUE9JTlQgPSAnaHR0cHM6Ly9mY21yZWdpc3RyYXRpb25zLmdvb2dsZWFwaXMuY29tL3YxJztcclxuY29uc3QgQ09OU09MRV9DQU1QQUlHTl9JRCA9ICdnb29nbGUuYy5hLmNfaWQnO1xyXG5jb25zdCBDT05TT0xFX0NBTVBBSUdOX05BTUUgPSAnZ29vZ2xlLmMuYS5jX2wnO1xyXG5jb25zdCBDT05TT0xFX0NBTVBBSUdOX1RJTUUgPSAnZ29vZ2xlLmMuYS50cyc7XHJcbi8qKiBTZXQgdG8gJzEnIGlmIEFuYWx5dGljcyBpcyBlbmFibGVkIGZvciB0aGUgY2FtcGFpZ24gKi9cclxuY29uc3QgQ09OU09MRV9DQU1QQUlHTl9BTkFMWVRJQ1NfRU5BQkxFRCA9ICdnb29nbGUuYy5hLmUnO1xyXG52YXIgTWVzc2FnZVR5cGUkMTtcclxuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xyXG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJEQVRBX01FU1NBR0VcIl0gPSAxXSA9IFwiREFUQV9NRVNTQUdFXCI7XHJcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkRJU1BMQVlfTk9USUZJQ0FUSU9OXCJdID0gM10gPSBcIkRJU1BMQVlfTk9USUZJQ0FUSU9OXCI7XHJcbn0pKE1lc3NhZ2VUeXBlJDEgfHwgKE1lc3NhZ2VUeXBlJDEgPSB7fSkpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxyXG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZVxyXG4gKiBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzc1xyXG4gKiBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIE1lc3NhZ2VUeXBlO1xyXG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XHJcbiAgICBNZXNzYWdlVHlwZVtcIlBVU0hfUkVDRUlWRURcIl0gPSBcInB1c2gtcmVjZWl2ZWRcIjtcclxuICAgIE1lc3NhZ2VUeXBlW1wiTk9USUZJQ0FUSU9OX0NMSUNLRURcIl0gPSBcIm5vdGlmaWNhdGlvbi1jbGlja2VkXCI7XHJcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5VG9CYXNlNjQoYXJyYXkpIHtcclxuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XHJcbiAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udWludDhBcnJheSkpO1xyXG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZy5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcclxufVxyXG5mdW5jdGlvbiBiYXNlNjRUb0FycmF5KGJhc2U2NFN0cmluZykge1xyXG4gICAgY29uc3QgcGFkZGluZyA9ICc9Jy5yZXBlYXQoKDQgLSAoYmFzZTY0U3RyaW5nLmxlbmd0aCAlIDQpKSAlIDQpO1xyXG4gICAgY29uc3QgYmFzZTY0ID0gKGJhc2U2NFN0cmluZyArIHBhZGRpbmcpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLS9nLCAnKycpXHJcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJy8nKTtcclxuICAgIGNvbnN0IHJhd0RhdGEgPSBhdG9iKGJhc2U2NCk7XHJcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IG5ldyBVaW50OEFycmF5KHJhd0RhdGEubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3RGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIG91dHB1dEFycmF5W2ldID0gcmF3RGF0YS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE9MRF9EQl9OQU1FID0gJ2ZjbV90b2tlbl9kZXRhaWxzX2RiJztcclxuLyoqXHJcbiAqIFRoZSBsYXN0IERCIHZlcnNpb24gb2YgJ2ZjbV90b2tlbl9kZXRhaWxzX2RiJyB3YXMgNC4gVGhpcyBpcyBvbmUgaGlnaGVyLCBzbyB0aGF0IHRoZSB1cGdyYWRlXHJcbiAqIGNhbGxiYWNrIGlzIGNhbGxlZCBmb3IgYWxsIHZlcnNpb25zIG9mIHRoZSBvbGQgREIuXHJcbiAqL1xyXG5jb25zdCBPTERfREJfVkVSU0lPTiA9IDU7XHJcbmNvbnN0IE9MRF9PQkpFQ1RfU1RPUkVfTkFNRSA9ICdmY21fdG9rZW5fb2JqZWN0X1N0b3JlJztcclxuYXN5bmMgZnVuY3Rpb24gbWlncmF0ZU9sZERhdGFiYXNlKHNlbmRlcklkKSB7XHJcbiAgICBpZiAoJ2RhdGFiYXNlcycgaW4gaW5kZXhlZERCKSB7XHJcbiAgICAgICAgLy8gaW5kZXhlZERiLmRhdGFiYXNlcygpIGlzIGFuIEluZGV4ZWREQiB2MyBBUEkgYW5kIGRvZXMgbm90IGV4aXN0IGluIGFsbCBicm93c2Vycy4gVE9ETzogUmVtb3ZlXHJcbiAgICAgICAgLy8gdHlwZWNhc3Qgd2hlbiBpdCBsYW5kcyBpbiBUUyB0eXBlcy5cclxuICAgICAgICBjb25zdCBkYXRhYmFzZXMgPSBhd2FpdCBpbmRleGVkREIuZGF0YWJhc2VzKCk7XHJcbiAgICAgICAgY29uc3QgZGJOYW1lcyA9IGRhdGFiYXNlcy5tYXAoZGIgPT4gZGIubmFtZSk7XHJcbiAgICAgICAgaWYgKCFkYk5hbWVzLmluY2x1ZGVzKE9MRF9EQl9OQU1FKSkge1xyXG4gICAgICAgICAgICAvLyBvbGQgREIgZGlkbid0IGV4aXN0LCBubyBuZWVkIHRvIG9wZW4uXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCB0b2tlbkRldGFpbHMgPSBudWxsO1xyXG4gICAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREIoT0xEX0RCX05BTUUsIE9MRF9EQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgdXBncmFkZTogYXN5bmMgKGRiLCBvbGRWZXJzaW9uLCBuZXdWZXJzaW9uLCB1cGdyYWRlVHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpZiAob2xkVmVyc2lvbiA8IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIERhdGFiYXNlIHRvbyBvbGQsIHNraXAgbWlncmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhPTERfT0JKRUNUX1NUT1JFX05BTUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEYXRhYmFzZSBkaWQgbm90IGV4aXN0LiBOb3RoaW5nIHRvIGRvLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdXBncmFkZVRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKE9MRF9PQkpFQ1RfU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgb2JqZWN0U3RvcmUuaW5kZXgoJ2ZjbVNlbmRlcklkJykuZ2V0KHNlbmRlcklkKTtcclxuICAgICAgICAgICAgYXdhaXQgb2JqZWN0U3RvcmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gZW50cnkgaW4gdGhlIGRhdGFiYXNlLCBub3RoaW5nIHRvIG1pZ3JhdGUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFZlcnNpb24gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZERldGFpbHMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghb2xkRGV0YWlscy5hdXRoIHx8ICFvbGREZXRhaWxzLnAyNTZkaCB8fCAhb2xkRGV0YWlscy5lbmRwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRva2VuRGV0YWlscyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogb2xkRGV0YWlscy5mY21Ub2tlbixcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUaW1lOiAoX2EgPSBvbGREZXRhaWxzLmNyZWF0ZVRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiBvbGREZXRhaWxzLmF1dGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyNTZkaDogb2xkRGV0YWlscy5wMjU2ZGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBvbGREZXRhaWxzLmVuZHBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd1Njb3BlOiBvbGREZXRhaWxzLnN3U2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcGlkS2V5OiB0eXBlb2Ygb2xkRGV0YWlscy52YXBpZEtleSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb2xkRGV0YWlscy52YXBpZEtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcnJheVRvQmFzZTY0KG9sZERldGFpbHMudmFwaWRLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbGRWZXJzaW9uID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREZXRhaWxzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0b2tlbkRldGFpbHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG9sZERldGFpbHMuZmNtVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGltZTogb2xkRGV0YWlscy5jcmVhdGVUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogYXJyYXlUb0Jhc2U2NChvbGREZXRhaWxzLmF1dGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwMjU2ZGg6IGFycmF5VG9CYXNlNjQob2xkRGV0YWlscy5wMjU2ZGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogb2xkRGV0YWlscy5lbmRwb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dTY29wZTogb2xkRGV0YWlscy5zd1Njb3BlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXBpZEtleTogYXJyYXlUb0Jhc2U2NChvbGREZXRhaWxzLnZhcGlkS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkVmVyc2lvbiA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRGV0YWlscyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG9rZW5EZXRhaWxzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBvbGREZXRhaWxzLmZjbVRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRpbWU6IG9sZERldGFpbHMuY3JlYXRlVGltZSxcclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IGFycmF5VG9CYXNlNjQob2xkRGV0YWlscy5hdXRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcDI1NmRoOiBhcnJheVRvQmFzZTY0KG9sZERldGFpbHMucDI1NmRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IG9sZERldGFpbHMuZW5kcG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3U2NvcGU6IG9sZERldGFpbHMuc3dTY29wZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFwaWRLZXk6IGFycmF5VG9CYXNlNjQob2xkRGV0YWlscy52YXBpZEtleSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBkYi5jbG9zZSgpO1xyXG4gICAgLy8gRGVsZXRlIGFsbCBvbGQgZGF0YWJhc2VzLlxyXG4gICAgYXdhaXQgZGVsZXRlREIoT0xEX0RCX05BTUUpO1xyXG4gICAgYXdhaXQgZGVsZXRlREIoJ2ZjbV92YXBpZF9kZXRhaWxzX2RiJyk7XHJcbiAgICBhd2FpdCBkZWxldGVEQigndW5kZWZpbmVkJyk7XHJcbiAgICByZXR1cm4gY2hlY2tUb2tlbkRldGFpbHModG9rZW5EZXRhaWxzKSA/IHRva2VuRGV0YWlscyA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tUb2tlbkRldGFpbHModG9rZW5EZXRhaWxzKSB7XHJcbiAgICBpZiAoIXRva2VuRGV0YWlscyB8fCAhdG9rZW5EZXRhaWxzLnN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbk9wdGlvbnMgfSA9IHRva2VuRGV0YWlscztcclxuICAgIHJldHVybiAodHlwZW9mIHRva2VuRGV0YWlscy5jcmVhdGVUaW1lID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIHRva2VuRGV0YWlscy5jcmVhdGVUaW1lID4gMCAmJlxyXG4gICAgICAgIHR5cGVvZiB0b2tlbkRldGFpbHMudG9rZW4gPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgdG9rZW5EZXRhaWxzLnRva2VuLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICB0eXBlb2Ygc3Vic2NyaXB0aW9uT3B0aW9ucy5hdXRoID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMuYXV0aC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgdHlwZW9mIHN1YnNjcmlwdGlvbk9wdGlvbnMucDI1NmRoID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMucDI1NmRoLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICB0eXBlb2Ygc3Vic2NyaXB0aW9uT3B0aW9ucy5lbmRwb2ludCA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zLmVuZHBvaW50Lmxlbmd0aCA+IDAgJiZcclxuICAgICAgICB0eXBlb2Ygc3Vic2NyaXB0aW9uT3B0aW9ucy5zd1Njb3BlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMuc3dTY29wZS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgdHlwZW9mIHN1YnNjcmlwdGlvbk9wdGlvbnMudmFwaWRLZXkgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucy52YXBpZEtleS5sZW5ndGggPiAwKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBFeHBvcnRlZCBmb3IgdGVzdHMuXHJcbmNvbnN0IERBVEFCQVNFX05BTUUgPSAnZmlyZWJhc2UtbWVzc2FnaW5nLWRhdGFiYXNlJztcclxuY29uc3QgREFUQUJBU0VfVkVSU0lPTiA9IDE7XHJcbmNvbnN0IE9CSkVDVF9TVE9SRV9OQU1FID0gJ2ZpcmViYXNlLW1lc3NhZ2luZy1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQVRBQkFTRV9OQU1FLCBEQVRBQkFTRV9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6ICh1cGdyYWRlRGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaCBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsXHJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2VcclxuICAgICAgICAgICAgICAgIC8vIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZURiLmNyZWF0ZU9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcclxufVxyXG4vKiogR2V0cyByZWNvcmQocykgZnJvbSB0aGUgb2JqZWN0U3RvcmUgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4ga2V5LiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkYkdldChmaXJlYmFzZURlcGVuZGVuY2llcykge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGZpcmViYXNlRGVwZW5kZW5jaWVzKTtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICBjb25zdCB0b2tlbkRldGFpbHMgPSAoYXdhaXQgZGJcclxuICAgICAgICAudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX05BTUUpXHJcbiAgICAgICAgLm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKVxyXG4gICAgICAgIC5nZXQoa2V5KSk7XHJcbiAgICBpZiAodG9rZW5EZXRhaWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuRGV0YWlscztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgdG9rZW5EZXRhaWxzIG9iamVjdCBpbiB0aGUgb2xkIERCLlxyXG4gICAgICAgIGNvbnN0IG9sZFRva2VuRGV0YWlscyA9IGF3YWl0IG1pZ3JhdGVPbGREYXRhYmFzZShmaXJlYmFzZURlcGVuZGVuY2llcy5hcHBDb25maWcuc2VuZGVySWQpO1xyXG4gICAgICAgIGlmIChvbGRUb2tlbkRldGFpbHMpIHtcclxuICAgICAgICAgICAgYXdhaXQgZGJTZXQoZmlyZWJhc2VEZXBlbmRlbmNpZXMsIG9sZFRva2VuRGV0YWlscyk7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRUb2tlbkRldGFpbHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBc3NpZ25zIG9yIG92ZXJ3cml0ZXMgdGhlIHJlY29yZCBmb3IgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGJTZXQoZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHRva2VuRGV0YWlscykge1xyXG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGZpcmViYXNlRGVwZW5kZW5jaWVzKTtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICBhd2FpdCB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfTkFNRSkucHV0KHRva2VuRGV0YWlscywga2V5KTtcclxuICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICByZXR1cm4gdG9rZW5EZXRhaWxzO1xyXG59XHJcbi8qKiBSZW1vdmVzIHJlY29yZChzKSBmcm9tIHRoZSBvYmplY3RTdG9yZSB0aGF0IG1hdGNoIHRoZSBnaXZlbiBrZXkuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRiUmVtb3ZlKGZpcmViYXNlRGVwZW5kZW5jaWVzKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoZmlyZWJhc2VEZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcclxuICAgIGF3YWl0IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKS5kZWxldGUoa2V5KTtcclxuICAgIGF3YWl0IHR4LmRvbmU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2V5KHsgYXBwQ29uZmlnIH0pIHtcclxuICAgIHJldHVybiBhcHBDb25maWcuYXBwSWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRVJST1JfTUFQID0ge1xyXG4gICAgW1wibWlzc2luZy1hcHAtY29uZmlnLXZhbHVlc1wiIC8qIEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DT05GSUdfVkFMVUVTICovXTogJ01pc3NpbmcgQXBwIGNvbmZpZ3VyYXRpb24gdmFsdWU6IFwieyR2YWx1ZU5hbWV9XCInLFxyXG4gICAgW1wib25seS1hdmFpbGFibGUtaW4td2luZG93XCIgLyogRXJyb3JDb2RlLkFWQUlMQUJMRV9JTl9XSU5ET1cgKi9dOiAnVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGluIGEgV2luZG93IGNvbnRleHQuJyxcclxuICAgIFtcIm9ubHktYXZhaWxhYmxlLWluLXN3XCIgLyogRXJyb3JDb2RlLkFWQUlMQUJMRV9JTl9TVyAqL106ICdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgaW4gYSBzZXJ2aWNlIHdvcmtlciBjb250ZXh0LicsXHJcbiAgICBbXCJwZXJtaXNzaW9uLWRlZmF1bHRcIiAvKiBFcnJvckNvZGUuUEVSTUlTU0lPTl9ERUZBVUxUICovXTogJ1RoZSBub3RpZmljYXRpb24gcGVybWlzc2lvbiB3YXMgbm90IGdyYW50ZWQgYW5kIGRpc21pc3NlZCBpbnN0ZWFkLicsXHJcbiAgICBbXCJwZXJtaXNzaW9uLWJsb2NrZWRcIiAvKiBFcnJvckNvZGUuUEVSTUlTU0lPTl9CTE9DS0VEICovXTogJ1RoZSBub3RpZmljYXRpb24gcGVybWlzc2lvbiB3YXMgbm90IGdyYW50ZWQgYW5kIGJsb2NrZWQgaW5zdGVhZC4nLFxyXG4gICAgW1widW5zdXBwb3J0ZWQtYnJvd3NlclwiIC8qIEVycm9yQ29kZS5VTlNVUFBPUlRFRF9CUk9XU0VSICovXTogXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBBUEkncyByZXF1aXJlZCB0byB1c2UgdGhlIEZpcmViYXNlIFNESy5cIixcclxuICAgIFtcImluZGV4ZWQtZGItdW5zdXBwb3J0ZWRcIiAvKiBFcnJvckNvZGUuSU5ERVhFRF9EQl9VTlNVUFBPUlRFRCAqL106IFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpbmRleGVkRGIub3BlbigpIChleC4gU2FmYXJpIGlGcmFtZSwgRmlyZWZveCBQcml2YXRlIEJyb3dzaW5nLCBldGMpXCIsXHJcbiAgICBbXCJmYWlsZWQtc2VydmljZS13b3JrZXItcmVnaXN0cmF0aW9uXCIgLyogRXJyb3JDb2RlLkZBSUxFRF9ERUZBVUxUX1JFR0lTVFJBVElPTiAqL106ICdXZSBhcmUgdW5hYmxlIHRvIHJlZ2lzdGVyIHRoZSBkZWZhdWx0IHNlcnZpY2Ugd29ya2VyLiB7JGJyb3dzZXJFcnJvck1lc3NhZ2V9JyxcclxuICAgIFtcInRva2VuLXN1YnNjcmliZS1mYWlsZWRcIiAvKiBFcnJvckNvZGUuVE9LRU5fU1VCU0NSSUJFX0ZBSUxFRCAqL106ICdBIHByb2JsZW0gb2NjdXJyZWQgd2hpbGUgc3Vic2NyaWJpbmcgdGhlIHVzZXIgdG8gRkNNOiB7JGVycm9ySW5mb30nLFxyXG4gICAgW1widG9rZW4tc3Vic2NyaWJlLW5vLXRva2VuXCIgLyogRXJyb3JDb2RlLlRPS0VOX1NVQlNDUklCRV9OT19UT0tFTiAqL106ICdGQ00gcmV0dXJuZWQgbm8gdG9rZW4gd2hlbiBzdWJzY3JpYmluZyB0aGUgdXNlciB0byBwdXNoLicsXHJcbiAgICBbXCJ0b2tlbi11bnN1YnNjcmliZS1mYWlsZWRcIiAvKiBFcnJvckNvZGUuVE9LRU5fVU5TVUJTQ1JJQkVfRkFJTEVEICovXTogJ0EgcHJvYmxlbSBvY2N1cnJlZCB3aGlsZSB1bnN1YnNjcmliaW5nIHRoZSAnICtcclxuICAgICAgICAndXNlciBmcm9tIEZDTTogeyRlcnJvckluZm99JyxcclxuICAgIFtcInRva2VuLXVwZGF0ZS1mYWlsZWRcIiAvKiBFcnJvckNvZGUuVE9LRU5fVVBEQVRFX0ZBSUxFRCAqL106ICdBIHByb2JsZW0gb2NjdXJyZWQgd2hpbGUgdXBkYXRpbmcgdGhlIHVzZXIgZnJvbSBGQ006IHskZXJyb3JJbmZvfScsXHJcbiAgICBbXCJ0b2tlbi11cGRhdGUtbm8tdG9rZW5cIiAvKiBFcnJvckNvZGUuVE9LRU5fVVBEQVRFX05PX1RPS0VOICovXTogJ0ZDTSByZXR1cm5lZCBubyB0b2tlbiB3aGVuIHVwZGF0aW5nIHRoZSB1c2VyIHRvIHB1c2guJyxcclxuICAgIFtcInVzZS1zdy1hZnRlci1nZXQtdG9rZW5cIiAvKiBFcnJvckNvZGUuVVNFX1NXX0FGVEVSX0dFVF9UT0tFTiAqL106ICdUaGUgdXNlU2VydmljZVdvcmtlcigpIG1ldGhvZCBtYXkgb25seSBiZSBjYWxsZWQgb25jZSBhbmQgbXVzdCBiZSAnICtcclxuICAgICAgICAnY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGdldFRva2VuKCkgdG8gZW5zdXJlIHlvdXIgc2VydmljZSB3b3JrZXIgaXMgdXNlZC4nLFxyXG4gICAgW1wiaW52YWxpZC1zdy1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuSU5WQUxJRF9TV19SRUdJU1RSQVRJT04gKi9dOiAnVGhlIGlucHV0IHRvIHVzZVNlcnZpY2VXb3JrZXIoKSBtdXN0IGJlIGEgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbi4nLFxyXG4gICAgW1wiaW52YWxpZC1iZy1oYW5kbGVyXCIgLyogRXJyb3JDb2RlLklOVkFMSURfQkdfSEFORExFUiAqL106ICdUaGUgaW5wdXQgdG8gc2V0QmFja2dyb3VuZE1lc3NhZ2VIYW5kbGVyKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicsXHJcbiAgICBbXCJpbnZhbGlkLXZhcGlkLWtleVwiIC8qIEVycm9yQ29kZS5JTlZBTElEX1ZBUElEX0tFWSAqL106ICdUaGUgcHVibGljIFZBUElEIGtleSBtdXN0IGJlIGEgc3RyaW5nLicsXHJcbiAgICBbXCJ1c2UtdmFwaWQta2V5LWFmdGVyLWdldC10b2tlblwiIC8qIEVycm9yQ29kZS5VU0VfVkFQSURfS0VZX0FGVEVSX0dFVF9UT0tFTiAqL106ICdUaGUgdXNlUHVibGljVmFwaWRLZXkoKSBtZXRob2QgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgYW5kIG11c3QgYmUgJyArXHJcbiAgICAgICAgJ2NhbGxlZCBiZWZvcmUgY2FsbGluZyBnZXRUb2tlbigpIHRvIGVuc3VyZSB5b3VyIFZBUElEIGtleSBpcyB1c2VkLidcclxufTtcclxuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ21lc3NhZ2luZycsICdNZXNzYWdpbmcnLCBFUlJPUl9NQVApO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0R2V0VG9rZW4oZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBnZXRIZWFkZXJzKGZpcmViYXNlRGVwZW5kZW5jaWVzKTtcclxuICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5KHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xyXG4gICAgY29uc3Qgc3Vic2NyaWJlT3B0aW9ucyA9IHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXHJcbiAgICB9O1xyXG4gICAgbGV0IHJlc3BvbnNlRGF0YTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChnZXRFbmRwb2ludChmaXJlYmFzZURlcGVuZGVuY2llcy5hcHBDb25maWcpLCBzdWJzY3JpYmVPcHRpb25zKTtcclxuICAgICAgICByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJ0b2tlbi1zdWJzY3JpYmUtZmFpbGVkXCIgLyogRXJyb3JDb2RlLlRPS0VOX1NVQlNDUklCRV9GQUlMRUQgKi8sIHtcclxuICAgICAgICAgICAgZXJyb3JJbmZvOiBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIudG9TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3BvbnNlRGF0YS5lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNwb25zZURhdGEuZXJyb3IubWVzc2FnZTtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInRva2VuLXN1YnNjcmliZS1mYWlsZWRcIiAvKiBFcnJvckNvZGUuVE9LRU5fU1VCU0NSSUJFX0ZBSUxFRCAqLywge1xyXG4gICAgICAgICAgICBlcnJvckluZm86IG1lc3NhZ2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghcmVzcG9uc2VEYXRhLnRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJ0b2tlbi1zdWJzY3JpYmUtbm8tdG9rZW5cIiAvKiBFcnJvckNvZGUuVE9LRU5fU1VCU0NSSUJFX05PX1RPS0VOICovKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNwb25zZURhdGEudG9rZW47XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZVRva2VuKGZpcmViYXNlRGVwZW5kZW5jaWVzLCB0b2tlbkRldGFpbHMpIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBnZXRIZWFkZXJzKGZpcmViYXNlRGVwZW5kZW5jaWVzKTtcclxuICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5KHRva2VuRGV0YWlscy5zdWJzY3JpcHRpb25PcHRpb25zKTtcclxuICAgIGNvbnN0IHVwZGF0ZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcclxuICAgIH07XHJcbiAgICBsZXQgcmVzcG9uc2VEYXRhO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2dldEVuZHBvaW50KGZpcmViYXNlRGVwZW5kZW5jaWVzLmFwcENvbmZpZyl9LyR7dG9rZW5EZXRhaWxzLnRva2VufWAsIHVwZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInRva2VuLXVwZGF0ZS1mYWlsZWRcIiAvKiBFcnJvckNvZGUuVE9LRU5fVVBEQVRFX0ZBSUxFRCAqLywge1xyXG4gICAgICAgICAgICBlcnJvckluZm86IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci50b1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzcG9uc2VEYXRhLmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlRGF0YS5lcnJvci5tZXNzYWdlO1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwidG9rZW4tdXBkYXRlLWZhaWxlZFwiIC8qIEVycm9yQ29kZS5UT0tFTl9VUERBVEVfRkFJTEVEICovLCB7XHJcbiAgICAgICAgICAgIGVycm9ySW5mbzogbWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZXNwb25zZURhdGEudG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInRva2VuLXVwZGF0ZS1uby10b2tlblwiIC8qIEVycm9yQ29kZS5UT0tFTl9VUERBVEVfTk9fVE9LRU4gKi8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlRGF0YS50b2tlbjtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0RGVsZXRlVG9rZW4oZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHRva2VuKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgZ2V0SGVhZGVycyhmaXJlYmFzZURlcGVuZGVuY2llcyk7XHJcbiAgICBjb25zdCB1bnN1YnNjcmliZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICBoZWFkZXJzXHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2dldEVuZHBvaW50KGZpcmViYXNlRGVwZW5kZW5jaWVzLmFwcENvbmZpZyl9LyR7dG9rZW59YCwgdW5zdWJzY3JpYmVPcHRpb25zKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5lcnJvcikge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzcG9uc2VEYXRhLmVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwidG9rZW4tdW5zdWJzY3JpYmUtZmFpbGVkXCIgLyogRXJyb3JDb2RlLlRPS0VOX1VOU1VCU0NSSUJFX0ZBSUxFRCAqLywge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvOiBtZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInRva2VuLXVuc3Vic2NyaWJlLWZhaWxlZFwiIC8qIEVycm9yQ29kZS5UT0tFTl9VTlNVQlNDUklCRV9GQUlMRUQgKi8sIHtcclxuICAgICAgICAgICAgZXJyb3JJbmZvOiBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIudG9TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEVuZHBvaW50KHsgcHJvamVjdElkIH0pIHtcclxuICAgIHJldHVybiBgJHtFTkRQT0lOVH0vcHJvamVjdHMvJHtwcm9qZWN0SWR9L3JlZ2lzdHJhdGlvbnNgO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldEhlYWRlcnMoeyBhcHBDb25maWcsIGluc3RhbGxhdGlvbnMgfSkge1xyXG4gICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgaW5zdGFsbGF0aW9ucy5nZXRUb2tlbigpO1xyXG4gICAgcmV0dXJuIG5ldyBIZWFkZXJzKHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICd4LWdvb2ctYXBpLWtleSc6IGFwcENvbmZpZy5hcGlLZXksXHJcbiAgICAgICAgJ3gtZ29vZy1maXJlYmFzZS1pbnN0YWxsYXRpb25zLWF1dGgnOiBgRklTICR7YXV0aFRva2VufWBcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEJvZHkoeyBwMjU2ZGgsIGF1dGgsIGVuZHBvaW50LCB2YXBpZEtleSB9KSB7XHJcbiAgICBjb25zdCBib2R5ID0ge1xyXG4gICAgICAgIHdlYjoge1xyXG4gICAgICAgICAgICBlbmRwb2ludCxcclxuICAgICAgICAgICAgYXV0aCxcclxuICAgICAgICAgICAgcDI1NmRoXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICh2YXBpZEtleSAhPT0gREVGQVVMVF9WQVBJRF9LRVkpIHtcclxuICAgICAgICBib2R5LndlYi5hcHBsaWNhdGlvblB1YktleSA9IHZhcGlkS2V5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvZHk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVXBkYXRlUmVnaXN0cmF0aW9uIHdpbGwgYmUgY2FsbGVkIG9uY2UgZXZlcnkgd2Vlay5cclxuY29uc3QgVE9LRU5fRVhQSVJBVElPTl9NUyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyA3IGRheXNcclxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW5JbnRlcm5hbChtZXNzYWdpbmcpIHtcclxuICAgIGNvbnN0IHB1c2hTdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRQdXNoU3Vic2NyaXB0aW9uKG1lc3NhZ2luZy5zd1JlZ2lzdHJhdGlvbiwgbWVzc2FnaW5nLnZhcGlkS2V5KTtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgdmFwaWRLZXk6IG1lc3NhZ2luZy52YXBpZEtleSxcclxuICAgICAgICBzd1Njb3BlOiBtZXNzYWdpbmcuc3dSZWdpc3RyYXRpb24uc2NvcGUsXHJcbiAgICAgICAgZW5kcG9pbnQ6IHB1c2hTdWJzY3JpcHRpb24uZW5kcG9pbnQsXHJcbiAgICAgICAgYXV0aDogYXJyYXlUb0Jhc2U2NChwdXNoU3Vic2NyaXB0aW9uLmdldEtleSgnYXV0aCcpKSxcclxuICAgICAgICBwMjU2ZGg6IGFycmF5VG9CYXNlNjQocHVzaFN1YnNjcmlwdGlvbi5nZXRLZXkoJ3AyNTZkaCcpKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHRva2VuRGV0YWlscyA9IGF3YWl0IGRiR2V0KG1lc3NhZ2luZy5maXJlYmFzZURlcGVuZGVuY2llcyk7XHJcbiAgICBpZiAoIXRva2VuRGV0YWlscykge1xyXG4gICAgICAgIC8vIE5vIHRva2VuLCBnZXQgYSBuZXcgb25lLlxyXG4gICAgICAgIHJldHVybiBnZXROZXdUb2tlbihtZXNzYWdpbmcuZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlzVG9rZW5WYWxpZCh0b2tlbkRldGFpbHMuc3Vic2NyaXB0aW9uT3B0aW9ucywgc3Vic2NyaXB0aW9uT3B0aW9ucykpIHtcclxuICAgICAgICAvLyBJbnZhbGlkIHRva2VuLCBnZXQgYSBuZXcgb25lLlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHJlcXVlc3REZWxldGVUb2tlbihtZXNzYWdpbmcuZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHRva2VuRGV0YWlscy50b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cHByZXNzIGVycm9ycyBiZWNhdXNlIG9mICMyMzY0XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldE5ld1Rva2VuKG1lc3NhZ2luZy5maXJlYmFzZURlcGVuZGVuY2llcywgc3Vic2NyaXB0aW9uT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChEYXRlLm5vdygpID49IHRva2VuRGV0YWlscy5jcmVhdGVUaW1lICsgVE9LRU5fRVhQSVJBVElPTl9NUykge1xyXG4gICAgICAgIC8vIFdlZWtseSB0b2tlbiByZWZyZXNoXHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVRva2VuKG1lc3NhZ2luZywge1xyXG4gICAgICAgICAgICB0b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuLFxyXG4gICAgICAgICAgICBjcmVhdGVUaW1lOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBWYWxpZCB0b2tlbiwgbm90aGluZyB0byBkby5cclxuICAgICAgICByZXR1cm4gdG9rZW5EZXRhaWxzLnRva2VuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBkZWxldGVzIHRoZSB0b2tlbiBmcm9tIHRoZSBkYXRhYmFzZSwgdW5zdWJzY3JpYmVzIHRoZSB0b2tlbiBmcm9tIEZDTSwgYW5kIHVucmVnaXN0ZXJzXHJcbiAqIHRoZSBwdXNoIHN1YnNjcmlwdGlvbiBpZiBpdCBleGlzdHMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVUb2tlbkludGVybmFsKG1lc3NhZ2luZykge1xyXG4gICAgY29uc3QgdG9rZW5EZXRhaWxzID0gYXdhaXQgZGJHZXQobWVzc2FnaW5nLmZpcmViYXNlRGVwZW5kZW5jaWVzKTtcclxuICAgIGlmICh0b2tlbkRldGFpbHMpIHtcclxuICAgICAgICBhd2FpdCByZXF1ZXN0RGVsZXRlVG9rZW4obWVzc2FnaW5nLmZpcmViYXNlRGVwZW5kZW5jaWVzLCB0b2tlbkRldGFpbHMudG9rZW4pO1xyXG4gICAgICAgIGF3YWl0IGRiUmVtb3ZlKG1lc3NhZ2luZy5maXJlYmFzZURlcGVuZGVuY2llcyk7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBmcm9tIHRoZSBwdXNoIHN1YnNjcmlwdGlvbi5cclxuICAgIGNvbnN0IHB1c2hTdWJzY3JpcHRpb24gPSBhd2FpdCBtZXNzYWdpbmcuc3dSZWdpc3RyYXRpb24ucHVzaE1hbmFnZXIuZ2V0U3Vic2NyaXB0aW9uKCk7XHJcbiAgICBpZiAocHVzaFN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIHJldHVybiBwdXNoU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGVyZSdzIG5vIFNXLCBjb25zaWRlciBpdCBhIHN1Y2Nlc3MuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVUb2tlbihtZXNzYWdpbmcsIHRva2VuRGV0YWlscykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkVG9rZW4gPSBhd2FpdCByZXF1ZXN0VXBkYXRlVG9rZW4obWVzc2FnaW5nLmZpcmViYXNlRGVwZW5kZW5jaWVzLCB0b2tlbkRldGFpbHMpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUb2tlbkRldGFpbHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRva2VuRGV0YWlscyksIHsgdG9rZW46IHVwZGF0ZWRUb2tlbiwgY3JlYXRlVGltZTogRGF0ZS5ub3coKSB9KTtcclxuICAgICAgICBhd2FpdCBkYlNldChtZXNzYWdpbmcuZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHVwZGF0ZWRUb2tlbkRldGFpbHMpO1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVkVG9rZW47XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZVRva2VuSW50ZXJuYWwobWVzc2FnaW5nKTtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldE5ld1Rva2VuKGZpcmViYXNlRGVwZW5kZW5jaWVzLCBzdWJzY3JpcHRpb25PcHRpb25zKSB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHJlcXVlc3RHZXRUb2tlbihmaXJlYmFzZURlcGVuZGVuY2llcywgc3Vic2NyaXB0aW9uT3B0aW9ucyk7XHJcbiAgICBjb25zdCB0b2tlbkRldGFpbHMgPSB7XHJcbiAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgY3JlYXRlVGltZTogRGF0ZS5ub3coKSxcclxuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zXHJcbiAgICB9O1xyXG4gICAgYXdhaXQgZGJTZXQoZmlyZWJhc2VEZXBlbmRlbmNpZXMsIHRva2VuRGV0YWlscyk7XHJcbiAgICByZXR1cm4gdG9rZW5EZXRhaWxzLnRva2VuO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIGEgUHVzaFN1YnNjcmlwdGlvbiBmb3IgdGhlIGN1cnJlbnQgdXNlci5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFB1c2hTdWJzY3JpcHRpb24oc3dSZWdpc3RyYXRpb24sIHZhcGlkS2V5KSB7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBzd1JlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlci5nZXRTdWJzY3JpcHRpb24oKTtcclxuICAgIGlmIChzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN3UmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyLnN1YnNjcmliZSh7XHJcbiAgICAgICAgdXNlclZpc2libGVPbmx5OiB0cnVlLFxyXG4gICAgICAgIC8vIENocm9tZSA8PSA3NSBkb2Vzbid0IHN1cHBvcnQgYmFzZTY0LWVuY29kZWQgVkFQSUQga2V5LiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgVkFQSUQga2V5XHJcbiAgICAgICAgLy8gc3VibWl0dGVkIHRvIHB1c2hNYW5hZ2VyI3N1YnNjcmliZSBtdXN0IGJlIG9mIHR5cGUgVWludDhBcnJheS5cclxuICAgICAgICBhcHBsaWNhdGlvblNlcnZlcktleTogYmFzZTY0VG9BcnJheSh2YXBpZEtleSlcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIHNhdmVkIHRva2VuRGV0YWlscyBvYmplY3QgbWF0Y2hlcyB0aGUgY29uZmlndXJhdGlvbiBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzVG9rZW5WYWxpZChkYk9wdGlvbnMsIGN1cnJlbnRPcHRpb25zKSB7XHJcbiAgICBjb25zdCBpc1ZhcGlkS2V5RXF1YWwgPSBjdXJyZW50T3B0aW9ucy52YXBpZEtleSA9PT0gZGJPcHRpb25zLnZhcGlkS2V5O1xyXG4gICAgY29uc3QgaXNFbmRwb2ludEVxdWFsID0gY3VycmVudE9wdGlvbnMuZW5kcG9pbnQgPT09IGRiT3B0aW9ucy5lbmRwb2ludDtcclxuICAgIGNvbnN0IGlzQXV0aEVxdWFsID0gY3VycmVudE9wdGlvbnMuYXV0aCA9PT0gZGJPcHRpb25zLmF1dGg7XHJcbiAgICBjb25zdCBpc1AyNTZkaEVxdWFsID0gY3VycmVudE9wdGlvbnMucDI1NmRoID09PSBkYk9wdGlvbnMucDI1NmRoO1xyXG4gICAgcmV0dXJuIGlzVmFwaWRLZXlFcXVhbCAmJiBpc0VuZHBvaW50RXF1YWwgJiYgaXNBdXRoRXF1YWwgJiYgaXNQMjU2ZGhFcXVhbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlcm5hbGl6ZVBheWxvYWQoaW50ZXJuYWxQYXlsb2FkKSB7XHJcbiAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIGZyb206IGludGVybmFsUGF5bG9hZC5mcm9tLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuICAgICAgICBjb2xsYXBzZUtleTogaW50ZXJuYWxQYXlsb2FkLmNvbGxhcHNlX2tleSxcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXHJcbiAgICAgICAgbWVzc2FnZUlkOiBpbnRlcm5hbFBheWxvYWQuZmNtTWVzc2FnZUlkXHJcbiAgICB9O1xyXG4gICAgcHJvcGFnYXRlTm90aWZpY2F0aW9uUGF5bG9hZChwYXlsb2FkLCBpbnRlcm5hbFBheWxvYWQpO1xyXG4gICAgcHJvcGFnYXRlRGF0YVBheWxvYWQocGF5bG9hZCwgaW50ZXJuYWxQYXlsb2FkKTtcclxuICAgIHByb3BhZ2F0ZUZjbU9wdGlvbnMocGF5bG9hZCwgaW50ZXJuYWxQYXlsb2FkKTtcclxuICAgIHJldHVybiBwYXlsb2FkO1xyXG59XHJcbmZ1bmN0aW9uIHByb3BhZ2F0ZU5vdGlmaWNhdGlvblBheWxvYWQocGF5bG9hZCwgbWVzc2FnZVBheWxvYWRJbnRlcm5hbCkge1xyXG4gICAgaWYgKCFtZXNzYWdlUGF5bG9hZEludGVybmFsLm5vdGlmaWNhdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHBheWxvYWQubm90aWZpY2F0aW9uID0ge307XHJcbiAgICBjb25zdCB0aXRsZSA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uLnRpdGxlO1xyXG4gICAgaWYgKCEhdGl0bGUpIHtcclxuICAgICAgICBwYXlsb2FkLm5vdGlmaWNhdGlvbi50aXRsZSA9IHRpdGxlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYm9keSA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uLmJvZHk7XHJcbiAgICBpZiAoISFib2R5KSB7XHJcbiAgICAgICAgcGF5bG9hZC5ub3RpZmljYXRpb24uYm9keSA9IGJvZHk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWFnZSA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uLmltYWdlO1xyXG4gICAgaWYgKCEhaW1hZ2UpIHtcclxuICAgICAgICBwYXlsb2FkLm5vdGlmaWNhdGlvbi5pbWFnZSA9IGltYWdlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaWNvbiA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uLmljb247XHJcbiAgICBpZiAoISFpY29uKSB7XHJcbiAgICAgICAgcGF5bG9hZC5ub3RpZmljYXRpb24uaWNvbiA9IGljb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvcGFnYXRlRGF0YVBheWxvYWQocGF5bG9hZCwgbWVzc2FnZVBheWxvYWRJbnRlcm5hbCkge1xyXG4gICAgaWYgKCFtZXNzYWdlUGF5bG9hZEludGVybmFsLmRhdGEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBwYXlsb2FkLmRhdGEgPSBtZXNzYWdlUGF5bG9hZEludGVybmFsLmRhdGE7XHJcbn1cclxuZnVuY3Rpb24gcHJvcGFnYXRlRmNtT3B0aW9ucyhwYXlsb2FkLCBtZXNzYWdlUGF5bG9hZEludGVybmFsKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgLy8gZmNtT3B0aW9ucy5saW5rIHZhbHVlIGlzIHdyaXR0ZW4gaW50byBub3RpZmljYXRpb24uY2xpY2tfYWN0aW9uLiBzZWUgbW9yZSBpbiBiLzIzMjA3MjExMVxyXG4gICAgaWYgKCFtZXNzYWdlUGF5bG9hZEludGVybmFsLmZjbU9wdGlvbnMgJiZcclxuICAgICAgICAhKChfYSA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpY2tfYWN0aW9uKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHBheWxvYWQuZmNtT3B0aW9ucyA9IHt9O1xyXG4gICAgY29uc3QgbGluayA9IChfYyA9IChfYiA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwuZmNtT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxpbmspICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IG1lc3NhZ2VQYXlsb2FkSW50ZXJuYWwubm90aWZpY2F0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2xpY2tfYWN0aW9uO1xyXG4gICAgaWYgKCEhbGluaykge1xyXG4gICAgICAgIHBheWxvYWQuZmNtT3B0aW9ucy5saW5rID0gbGluaztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuICAgIGNvbnN0IGFuYWx5dGljc0xhYmVsID0gKF9lID0gbWVzc2FnZVBheWxvYWRJbnRlcm5hbC5mY21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYW5hbHl0aWNzX2xhYmVsO1xyXG4gICAgaWYgKCEhYW5hbHl0aWNzTGFiZWwpIHtcclxuICAgICAgICBwYXlsb2FkLmZjbU9wdGlvbnMuYW5hbHl0aWNzTGFiZWwgPSBhbmFseXRpY3NMYWJlbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbnNvbGVNZXNzYWdlKGRhdGEpIHtcclxuICAgIC8vIFRoaXMgbWVzc2FnZSBoYXMgYSBjYW1wYWlnbiBJRCwgbWVhbmluZyBpdCB3YXMgc2VudCB1c2luZyB0aGUgRmlyZWJhc2UgQ29uc29sZS5cclxuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgISFkYXRhICYmIENPTlNPTEVfQ0FNUEFJR05fSUQgaW4gZGF0YTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5fbWVyZ2VTdHJpbmdzKCdodHMvZnJic2xnaWdwLm9nZXBzY212L2llby9lYXlsZycsICd0cDovaWVhZW9nbi1hZ29sYWkuby8xZnJsZ2xnYy9vJyk7XHJcbl9tZXJnZVN0cmluZ3MoJ0F6U0NidzYzZzFSMG5Ddzg1akc4JywgJ0lheWEzeUxLd21ndmg3Y0YwcTQnKTtcclxuZnVuY3Rpb24gX21lcmdlU3RyaW5ncyhzMSwgczIpIHtcclxuICAgIGNvbnN0IHJlc3VsdEFycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChzMS5jaGFyQXQoaSkpO1xyXG4gICAgICAgIGlmIChpIDwgczIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2goczIuY2hhckF0KGkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0QXJyYXkuam9pbignJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEFwcENvbmZpZyhhcHApIHtcclxuICAgIGlmICghYXBwIHx8ICFhcHAub3B0aW9ucykge1xyXG4gICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKCdBcHAgQ29uZmlndXJhdGlvbiBPYmplY3QnKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwLm5hbWUpIHtcclxuICAgICAgICB0aHJvdyBnZXRNaXNzaW5nVmFsdWVFcnJvcignQXBwIE5hbWUnKTtcclxuICAgIH1cclxuICAgIC8vIFJlcXVpcmVkIGFwcCBjb25maWcga2V5c1xyXG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtcclxuICAgICAgICAncHJvamVjdElkJyxcclxuICAgICAgICAnYXBpS2V5JyxcclxuICAgICAgICAnYXBwSWQnLFxyXG4gICAgICAgICdtZXNzYWdpbmdTZW5kZXJJZCdcclxuICAgIF07XHJcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGFwcDtcclxuICAgIGZvciAoY29uc3Qga2V5TmFtZSBvZiBjb25maWdLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zW2tleU5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKGtleU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwTmFtZTogYXBwLm5hbWUsXHJcbiAgICAgICAgcHJvamVjdElkOiBvcHRpb25zLnByb2plY3RJZCxcclxuICAgICAgICBhcGlLZXk6IG9wdGlvbnMuYXBpS2V5LFxyXG4gICAgICAgIGFwcElkOiBvcHRpb25zLmFwcElkLFxyXG4gICAgICAgIHNlbmRlcklkOiBvcHRpb25zLm1lc3NhZ2luZ1NlbmRlcklkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pc3NpbmdWYWx1ZUVycm9yKHZhbHVlTmFtZSkge1xyXG4gICAgcmV0dXJuIEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibWlzc2luZy1hcHAtY29uZmlnLXZhbHVlc1wiIC8qIEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DT05GSUdfVkFMVUVTICovLCB7XHJcbiAgICAgICAgdmFsdWVOYW1lXHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZXNzYWdpbmdTZXJ2aWNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgaW5zdGFsbGF0aW9ucywgYW5hbHl0aWNzUHJvdmlkZXIpIHtcclxuICAgICAgICAvLyBsb2dnaW5nIGlzIG9ubHkgZG9uZSB3aXRoIGVuZCB1c2VyIGNvbnNlbnQuIERlZmF1bHQgdG8gZmFsc2UuXHJcbiAgICAgICAgdGhpcy5kZWxpdmVyeU1ldHJpY3NFeHBvcnRlZFRvQmlnUXVlcnlFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkJhY2tncm91bmRNZXNzYWdlSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvZ0V2ZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNMb2dTZXJ2aWNlU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcENvbmZpZyA9IGV4dHJhY3RBcHBDb25maWcoYXBwKTtcclxuICAgICAgICB0aGlzLmZpcmViYXNlRGVwZW5kZW5jaWVzID0ge1xyXG4gICAgICAgICAgICBhcHAsXHJcbiAgICAgICAgICAgIGFwcENvbmZpZyxcclxuICAgICAgICAgICAgaW5zdGFsbGF0aW9ucyxcclxuICAgICAgICAgICAgYW5hbHl0aWNzUHJvdmlkZXJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0U3cobWVzc2FnaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1lc3NhZ2luZy5zd1JlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKERFRkFVTFRfU1dfUEFUSCwge1xyXG4gICAgICAgICAgICBzY29wZTogREVGQVVMVF9TV19TQ09QRVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRoZSB0aW1pbmcgd2hlbiBicm93c2VyIHVwZGF0ZXMgc3cgd2hlbiBzdyBoYXMgYW4gdXBkYXRlIGlzIHVucmVsaWFibGUgZnJvbSBleHBlcmltZW50LiBJdFxyXG4gICAgICAgIC8vIGxlYWRzIHRvIHZlcnNpb24gY29uZmxpY3Qgd2hlbiB0aGUgU0RLIHVwZ3JhZGVzIHRvIGEgbmV3ZXIgdmVyc2lvbiBpbiB0aGUgbWFpbiBwYWdlLCBidXQgc3dcclxuICAgICAgICAvLyBpcyBzdHVjayB3aXRoIHRoZSBvbGQgdmVyc2lvbi4gRm9yIGV4YW1wbGUsXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvMjU5MCBUaGUgZm9sbG93aW5nIGxpbmUgcmVsaWFibHkgdXBkYXRlc1xyXG4gICAgICAgIC8vIHN3IGlmIHRoZXJlIHdhcyBhbiB1cGRhdGUuXHJcbiAgICAgICAgbWVzc2FnaW5nLnN3UmVnaXN0cmF0aW9uLnVwZGF0ZSgpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgLyogaXQgaXMgbm9uIGJsb2NraW5nIGFuZCB3ZSBkb24ndCBjYXJlIGlmIGl0IGZhaWxlZCAqL1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZhaWxlZC1zZXJ2aWNlLXdvcmtlci1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuRkFJTEVEX0RFRkFVTFRfUkVHSVNUUkFUSU9OICovLCB7XHJcbiAgICAgICAgICAgIGJyb3dzZXJFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlU3dSZWcobWVzc2FnaW5nLCBzd1JlZ2lzdHJhdGlvbikge1xyXG4gICAgaWYgKCFzd1JlZ2lzdHJhdGlvbiAmJiAhbWVzc2FnaW5nLnN3UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgYXdhaXQgcmVnaXN0ZXJEZWZhdWx0U3cobWVzc2FnaW5nKTtcclxuICAgIH1cclxuICAgIGlmICghc3dSZWdpc3RyYXRpb24gJiYgISFtZXNzYWdpbmcuc3dSZWdpc3RyYXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIShzd1JlZ2lzdHJhdGlvbiBpbnN0YW5jZW9mIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLXN3LXJlZ2lzdHJhdGlvblwiIC8qIEVycm9yQ29kZS5JTlZBTElEX1NXX1JFR0lTVFJBVElPTiAqLyk7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdpbmcuc3dSZWdpc3RyYXRpb24gPSBzd1JlZ2lzdHJhdGlvbjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVWYXBpZEtleShtZXNzYWdpbmcsIHZhcGlkS2V5KSB7XHJcbiAgICBpZiAoISF2YXBpZEtleSkge1xyXG4gICAgICAgIG1lc3NhZ2luZy52YXBpZEtleSA9IHZhcGlkS2V5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIW1lc3NhZ2luZy52YXBpZEtleSkge1xyXG4gICAgICAgIG1lc3NhZ2luZy52YXBpZEtleSA9IERFRkFVTFRfVkFQSURfS0VZO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuJDEobWVzc2FnaW5nLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIW5hdmlnYXRvcikge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwib25seS1hdmFpbGFibGUtaW4td2luZG93XCIgLyogRXJyb3JDb2RlLkFWQUlMQUJMRV9JTl9XSU5ET1cgKi8pO1xyXG4gICAgfVxyXG4gICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICBhd2FpdCBOb3RpZmljYXRpb24ucmVxdWVzdFBlcm1pc3Npb24oKTtcclxuICAgIH1cclxuICAgIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gJ2dyYW50ZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJwZXJtaXNzaW9uLWJsb2NrZWRcIiAvKiBFcnJvckNvZGUuUEVSTUlTU0lPTl9CTE9DS0VEICovKTtcclxuICAgIH1cclxuICAgIGF3YWl0IHVwZGF0ZVZhcGlkS2V5KG1lc3NhZ2luZywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZhcGlkS2V5KTtcclxuICAgIGF3YWl0IHVwZGF0ZVN3UmVnKG1lc3NhZ2luZywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24pO1xyXG4gICAgcmV0dXJuIGdldFRva2VuSW50ZXJuYWwobWVzc2FnaW5nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2dUb1NjaW9uKG1lc3NhZ2luZywgbWVzc2FnZVR5cGUsIGRhdGEpIHtcclxuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGdldEV2ZW50VHlwZShtZXNzYWdlVHlwZSk7XHJcbiAgICBjb25zdCBhbmFseXRpY3MgPSBhd2FpdCBtZXNzYWdpbmcuZmlyZWJhc2VEZXBlbmRlbmNpZXMuYW5hbHl0aWNzUHJvdmlkZXIuZ2V0KCk7XHJcbiAgICBhbmFseXRpY3MubG9nRXZlbnQoZXZlbnRUeXBlLCB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXHJcbiAgICAgICAgbWVzc2FnZV9pZDogZGF0YVtDT05TT0xFX0NBTVBBSUdOX0lEXSxcclxuICAgICAgICBtZXNzYWdlX25hbWU6IGRhdGFbQ09OU09MRV9DQU1QQUlHTl9OQU1FXSxcclxuICAgICAgICBtZXNzYWdlX3RpbWU6IGRhdGFbQ09OU09MRV9DQU1QQUlHTl9USU1FXSxcclxuICAgICAgICBtZXNzYWdlX2RldmljZV90aW1lOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRFdmVudFR5cGUobWVzc2FnZVR5cGUpIHtcclxuICAgIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcclxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLk5PVElGSUNBVElPTl9DTElDS0VEOlxyXG4gICAgICAgICAgICByZXR1cm4gJ25vdGlmaWNhdGlvbl9vcGVuJztcclxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBVU0hfUkVDRUlWRUQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnbm90aWZpY2F0aW9uX2ZvcmVncm91bmQnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VFdmVudExpc3RlbmVyKG1lc3NhZ2luZywgZXZlbnQpIHtcclxuICAgIGNvbnN0IGludGVybmFsUGF5bG9hZCA9IGV2ZW50LmRhdGE7XHJcbiAgICBpZiAoIWludGVybmFsUGF5bG9hZC5pc0ZpcmViYXNlTWVzc2FnaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKG1lc3NhZ2luZy5vbk1lc3NhZ2VIYW5kbGVyICYmXHJcbiAgICAgICAgaW50ZXJuYWxQYXlsb2FkLm1lc3NhZ2VUeXBlID09PSBNZXNzYWdlVHlwZS5QVVNIX1JFQ0VJVkVEKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdpbmcub25NZXNzYWdlSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBtZXNzYWdpbmcub25NZXNzYWdlSGFuZGxlcihleHRlcm5hbGl6ZVBheWxvYWQoaW50ZXJuYWxQYXlsb2FkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdpbmcub25NZXNzYWdlSGFuZGxlci5uZXh0KGV4dGVybmFsaXplUGF5bG9hZChpbnRlcm5hbFBheWxvYWQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBMb2cgdG8gU2Npb24gaWYgYXBwbGljYWJsZVxyXG4gICAgY29uc3QgZGF0YVBheWxvYWQgPSBpbnRlcm5hbFBheWxvYWQuZGF0YTtcclxuICAgIGlmIChpc0NvbnNvbGVNZXNzYWdlKGRhdGFQYXlsb2FkKSAmJlxyXG4gICAgICAgIGRhdGFQYXlsb2FkW0NPTlNPTEVfQ0FNUEFJR05fQU5BTFlUSUNTX0VOQUJMRURdID09PSAnMScpIHtcclxuICAgICAgICBhd2FpdCBsb2dUb1NjaW9uKG1lc3NhZ2luZywgaW50ZXJuYWxQYXlsb2FkLm1lc3NhZ2VUeXBlLCBkYXRhUGF5bG9hZCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xMi40XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFdpbmRvd01lc3NhZ2luZ0ZhY3RvcnkgPSAoY29udGFpbmVyKSA9PiB7XHJcbiAgICBjb25zdCBtZXNzYWdpbmcgPSBuZXcgTWVzc2FnaW5nU2VydmljZShjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpLCBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2luc3RhbGxhdGlvbnMtaW50ZXJuYWwnKS5nZXRJbW1lZGlhdGUoKSwgY29udGFpbmVyLmdldFByb3ZpZGVyKCdhbmFseXRpY3MtaW50ZXJuYWwnKSk7XHJcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZSA9PiBtZXNzYWdlRXZlbnRMaXN0ZW5lcihtZXNzYWdpbmcsIGUpKTtcclxuICAgIHJldHVybiBtZXNzYWdpbmc7XHJcbn07XHJcbmNvbnN0IFdpbmRvd01lc3NhZ2luZ0ludGVybmFsRmFjdG9yeSA9IChjb250YWluZXIpID0+IHtcclxuICAgIGNvbnN0IG1lc3NhZ2luZyA9IGNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignbWVzc2FnaW5nJylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICBjb25zdCBtZXNzYWdpbmdJbnRlcm5hbCA9IHtcclxuICAgICAgICBnZXRUb2tlbjogKG9wdGlvbnMpID0+IGdldFRva2VuJDEobWVzc2FnaW5nLCBvcHRpb25zKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBtZXNzYWdpbmdJbnRlcm5hbDtcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJNZXNzYWdpbmdJbldpbmRvdygpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdtZXNzYWdpbmcnLCBXaW5kb3dNZXNzYWdpbmdGYWN0b3J5LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnbWVzc2FnaW5nLWludGVybmFsJywgV2luZG93TWVzc2FnaW5nSW50ZXJuYWxGYWN0b3J5LCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2hlY2tzIGlmIGFsbCByZXF1aXJlZCBBUElzIGV4aXN0IGluIHRoZSBicm93c2VyLlxyXG4gKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlzV2luZG93U3VwcG9ydGVkKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBUaGlzIHRocm93cyBpZiBvcGVuKCkgaXMgdW5zdXBwb3J0ZWQsIHNvIGFkZGluZyBpdCB0byB0aGUgY29uZGl0aW9uYWxcclxuICAgICAgICAvLyBzdGF0ZW1lbnQgYmVsb3cgY2FuIGNhdXNlIGFuIHVuY2F1Z2h0IGVycm9yLlxyXG4gICAgICAgIGF3YWl0IHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy8yMzkzIHJldmVhbHMgdGhhdCBpZGIjb3BlbiBpbiBTYWZhcmkgaWZyYW1lIGFuZCBGaXJlZm94IHByaXZhdGUgYnJvd3NpbmdcclxuICAgIC8vIG1pZ2h0IGJlIHByb2hpYml0ZWQgdG8gcnVuLiBJbiB0aGVzZSBjb250ZXh0cywgYW4gZXJyb3Igd291bGQgYmUgdGhyb3duIGR1cmluZyB0aGUgbWVzc2FnaW5nXHJcbiAgICAvLyBpbnN0YW50aWF0aW5nIHBoYXNlLCBpbmZvcm1pbmcgdGhlIGRldmVsb3BlcnMgdG8gaW1wb3J0L2NhbGwgaXNTdXBwb3J0ZWQgZm9yIHNwZWNpYWwgaGFuZGxpbmcuXHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgaXNJbmRleGVkREJBdmFpbGFibGUoKSAmJlxyXG4gICAgICAgIGFyZUNvb2tpZXNFbmFibGVkKCkgJiZcclxuICAgICAgICAnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yICYmXHJcbiAgICAgICAgJ1B1c2hNYW5hZ2VyJyBpbiB3aW5kb3cgJiZcclxuICAgICAgICAnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiZcclxuICAgICAgICAnZmV0Y2gnIGluIHdpbmRvdyAmJlxyXG4gICAgICAgIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24ucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzaG93Tm90aWZpY2F0aW9uJykgJiZcclxuICAgICAgICBQdXNoU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnZ2V0S2V5JykpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRva2VuJDEobWVzc2FnaW5nKSB7XHJcbiAgICBpZiAoIW5hdmlnYXRvcikge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwib25seS1hdmFpbGFibGUtaW4td2luZG93XCIgLyogRXJyb3JDb2RlLkFWQUlMQUJMRV9JTl9XSU5ET1cgKi8pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFtZXNzYWdpbmcuc3dSZWdpc3RyYXRpb24pIHtcclxuICAgICAgICBhd2FpdCByZWdpc3RlckRlZmF1bHRTdyhtZXNzYWdpbmcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGV0ZVRva2VuSW50ZXJuYWwobWVzc2FnaW5nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbk1lc3NhZ2UkMShtZXNzYWdpbmcsIG5leHRPck9ic2VydmVyKSB7XHJcbiAgICBpZiAoIW5hdmlnYXRvcikge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwib25seS1hdmFpbGFibGUtaW4td2luZG93XCIgLyogRXJyb3JDb2RlLkFWQUlMQUJMRV9JTl9XSU5ET1cgKi8pO1xyXG4gICAgfVxyXG4gICAgbWVzc2FnaW5nLm9uTWVzc2FnZUhhbmRsZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbWVzc2FnaW5nLm9uTWVzc2FnZUhhbmRsZXIgPSBudWxsO1xyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0cmlldmVzIGEgRmlyZWJhc2UgQ2xvdWQgTWVzc2FnaW5nIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgRmlyZWJhc2UgQ2xvdWQgTWVzc2FnaW5nIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgZmlyZWJhc2UgYXBwLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdpbmdJbldpbmRvdyhhcHAgPSBnZXRBcHAoKSkge1xyXG4gICAgLy8gQ29uc2Npb3VzIGRlY2lzaW9uIHRvIG1ha2UgdGhpcyBhc3luYyBjaGVjayBub24tYmxvY2tpbmcgZHVyaW5nIHRoZSBtZXNzYWdpbmcgaW5zdGFuY2VcclxuICAgIC8vIGluaXRpYWxpemF0aW9uIHBoYXNlIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLiBBbiBlcnJvciB3b3VsZCBiZSB0aHJvd24gbGF0dGVyIGZvclxyXG4gICAgLy8gZGV2ZWxvcGVyJ3MgaW5mb3JtYXRpb24uIERldmVsb3BlcnMgY2FuIHRoZW4gY2hvb3NlIHRvIGltcG9ydCBhbmQgY2FsbCBgaXNTdXBwb3J0ZWRgIGZvclxyXG4gICAgLy8gc3BlY2lhbCBoYW5kbGluZy5cclxuICAgIGlzV2luZG93U3VwcG9ydGVkKCkudGhlbihpc1N1cHBvcnRlZCA9PiB7XHJcbiAgICAgICAgLy8gSWYgYGlzV2luZG93U3VwcG9ydGVkKClgIHJlc29sdmVkLCBidXQgcmV0dXJuZWQgZmFsc2UuXHJcbiAgICAgICAgaWYgKCFpc1N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInVuc3VwcG9ydGVkLWJyb3dzZXJcIiAvKiBFcnJvckNvZGUuVU5TVVBQT1JURURfQlJPV1NFUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgXyA9PiB7XHJcbiAgICAgICAgLy8gSWYgYGlzV2luZG93U3VwcG9ydGVkKClgIHJlamVjdGVkLlxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5kZXhlZC1kYi11bnN1cHBvcnRlZFwiIC8qIEVycm9yQ29kZS5JTkRFWEVEX0RCX1VOU1VQUE9SVEVEICovKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9nZXRQcm92aWRlcihnZXRNb2R1bGFySW5zdGFuY2UoYXBwKSwgJ21lc3NhZ2luZycpLmdldEltbWVkaWF0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBTdWJzY3JpYmVzIHRoZSB7QGxpbmsgTWVzc2FnaW5nfSBpbnN0YW5jZSB0byBwdXNoIG5vdGlmaWNhdGlvbnMuIFJldHVybnMgYW4gRmlyZWJhc2UgQ2xvdWRcclxuICogTWVzc2FnaW5nIHJlZ2lzdHJhdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlbmQgcHVzaCBtZXNzYWdlcyB0byB0aGF0IHtAbGluayBNZXNzYWdpbmd9XHJcbiAqIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBJZiBhIG5vdGlmaWNhdGlvbiBwZXJtaXNzaW9uIGlzbid0IGFscmVhZHkgZ3JhbnRlZCwgdGhpcyBtZXRob2QgYXNrcyB0aGUgdXNlciBmb3IgcGVybWlzc2lvbi4gVGhlXHJcbiAqIHJldHVybmVkIHByb21pc2UgcmVqZWN0cyBpZiB0aGUgdXNlciBkb2VzIG5vdCBhbGxvdyB0aGUgYXBwIHRvIHNob3cgbm90aWZpY2F0aW9ucy5cclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2luZyAtIFRoZSB7QGxpbmsgTWVzc2FnaW5nfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBQcm92aWRlcyBhbiBvcHRpb25hbCB2YXBpZCBrZXkgYW5kIGFuIG9wdGlub2FsIHNlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvblxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIGFuIEZDTSByZWdpc3RyYXRpb24gdG9rZW4uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKG1lc3NhZ2luZywgb3B0aW9ucykge1xyXG4gICAgbWVzc2FnaW5nID0gZ2V0TW9kdWxhckluc3RhbmNlKG1lc3NhZ2luZyk7XHJcbiAgICByZXR1cm4gZ2V0VG9rZW4kMShtZXNzYWdpbmcsIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBEZWxldGVzIHRoZSByZWdpc3RyYXRpb24gdG9rZW4gYXNzb2NpYXRlZCB3aXRoIHRoaXMge0BsaW5rIE1lc3NhZ2luZ30gaW5zdGFuY2UgYW5kIHVuc3Vic2NyaWJlc1xyXG4gKiB0aGUge0BsaW5rIE1lc3NhZ2luZ30gaW5zdGFuY2UgZnJvbSB0aGUgcHVzaCBzdWJzY3JpcHRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXNzYWdpbmcgLSBUaGUge0BsaW5rIE1lc3NhZ2luZ30gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHJlc29sdmVzIHdoZW4gdGhlIHRva2VuIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBkZWxldGVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVUb2tlbihtZXNzYWdpbmcpIHtcclxuICAgIG1lc3NhZ2luZyA9IGdldE1vZHVsYXJJbnN0YW5jZShtZXNzYWdpbmcpO1xyXG4gICAgcmV0dXJuIGRlbGV0ZVRva2VuJDEobWVzc2FnaW5nKTtcclxufVxyXG4vKipcclxuICogV2hlbiBhIHB1c2ggbWVzc2FnZSBpcyByZWNlaXZlZCBhbmQgdGhlIHVzZXIgaXMgY3VycmVudGx5IG9uIGEgcGFnZSBmb3IgeW91ciBvcmlnaW4sIHRoZVxyXG4gKiBtZXNzYWdlIGlzIHBhc3NlZCB0byB0aGUgcGFnZSBhbmQgYW4gYG9uTWVzc2FnZSgpYCBldmVudCBpcyBkaXNwYXRjaGVkIHdpdGggdGhlIHBheWxvYWQgb2ZcclxuICogdGhlIHB1c2ggbWVzc2FnZS5cclxuICpcclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2luZyAtIFRoZSB7QGxpbmsgTWVzc2FnaW5nfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gVGhpcyBmdW5jdGlvbiwgb3Igb2JzZXJ2ZXIgb2JqZWN0IHdpdGggYG5leHRgIGRlZmluZWQsXHJcbiAqICAgICBpcyBjYWxsZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgYW5kIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB2aWV3aW5nIHlvdXIgcGFnZS5cclxuICogQHJldHVybnMgVG8gc3RvcCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzIGV4ZWN1dGUgdGhpcyByZXR1cm5lZCBmdW5jdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2luZywgbmV4dE9yT2JzZXJ2ZXIpIHtcclxuICAgIG1lc3NhZ2luZyA9IGdldE1vZHVsYXJJbnN0YW5jZShtZXNzYWdpbmcpO1xyXG4gICAgcmV0dXJuIG9uTWVzc2FnZSQxKG1lc3NhZ2luZywgbmV4dE9yT2JzZXJ2ZXIpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBDbG91ZCBNZXNzYWdpbmdcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3Rlck1lc3NhZ2luZ0luV2luZG93KCk7XG5cbmV4cG9ydCB7IGRlbGV0ZVRva2VuLCBnZXRNZXNzYWdpbmdJbldpbmRvdyBhcyBnZXRNZXNzYWdpbmcsIGdldFRva2VuLCBpc1dpbmRvd1N1cHBvcnRlZCBhcyBpc1N1cHBvcnRlZCwgb25NZXNzYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIm9wZW5EQiIsImRlbGV0ZURCIiwiRXJyb3JGYWN0b3J5IiwidmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSIsImlzSW5kZXhlZERCQXZhaWxhYmxlIiwiYXJlQ29va2llc0VuYWJsZWQiLCJnZXRNb2R1bGFySW5zdGFuY2UiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJfZ2V0UHJvdmlkZXIiLCJnZXRBcHAiLCJERUZBVUxUX1NXX1BBVEgiLCJERUZBVUxUX1NXX1NDT1BFIiwiREVGQVVMVF9WQVBJRF9LRVkiLCJFTkRQT0lOVCIsIkNPTlNPTEVfQ0FNUEFJR05fSUQiLCJDT05TT0xFX0NBTVBBSUdOX05BTUUiLCJDT05TT0xFX0NBTVBBSUdOX1RJTUUiLCJDT05TT0xFX0NBTVBBSUdOX0FOQUxZVElDU19FTkFCTEVEIiwiTWVzc2FnZVR5cGUkMSIsIk1lc3NhZ2VUeXBlIiwiYXJyYXlUb0Jhc2U2NCIsImFycmF5IiwidWludDhBcnJheSIsIlVpbnQ4QXJyYXkiLCJiYXNlNjRTdHJpbmciLCJidG9hIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicmVwbGFjZSIsImJhc2U2NFRvQXJyYXkiLCJwYWRkaW5nIiwicmVwZWF0IiwibGVuZ3RoIiwiYmFzZTY0IiwicmF3RGF0YSIsImF0b2IiLCJvdXRwdXRBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiT0xEX0RCX05BTUUiLCJPTERfREJfVkVSU0lPTiIsIk9MRF9PQkpFQ1RfU1RPUkVfTkFNRSIsIm1pZ3JhdGVPbGREYXRhYmFzZSIsInNlbmRlcklkIiwiaW5kZXhlZERCIiwiZGF0YWJhc2VzIiwiZGJOYW1lcyIsIm1hcCIsImRiIiwibmFtZSIsImluY2x1ZGVzIiwidG9rZW5EZXRhaWxzIiwidXBncmFkZSIsIm9sZFZlcnNpb24iLCJuZXdWZXJzaW9uIiwidXBncmFkZVRyYW5zYWN0aW9uIiwiX2EiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJvYmplY3RTdG9yZSIsInZhbHVlIiwiaW5kZXgiLCJnZXQiLCJjbGVhciIsIm9sZERldGFpbHMiLCJhdXRoIiwicDI1NmRoIiwiZW5kcG9pbnQiLCJ0b2tlbiIsImZjbVRva2VuIiwiY3JlYXRlVGltZSIsIkRhdGUiLCJub3ciLCJzdWJzY3JpcHRpb25PcHRpb25zIiwic3dTY29wZSIsInZhcGlkS2V5IiwiY2xvc2UiLCJjaGVja1Rva2VuRGV0YWlscyIsIkRBVEFCQVNFX05BTUUiLCJEQVRBQkFTRV9WRVJTSU9OIiwiT0JKRUNUX1NUT1JFX05BTUUiLCJkYlByb21pc2UiLCJnZXREYlByb21pc2UiLCJ1cGdyYWRlRGIiLCJjcmVhdGVPYmplY3RTdG9yZSIsImRiR2V0IiwiZmlyZWJhc2VEZXBlbmRlbmNpZXMiLCJrZXkiLCJnZXRLZXkiLCJ0cmFuc2FjdGlvbiIsIm9sZFRva2VuRGV0YWlscyIsImFwcENvbmZpZyIsImRiU2V0IiwidHgiLCJwdXQiLCJkb25lIiwiZGJSZW1vdmUiLCJkZWxldGUiLCJhcHBJZCIsIkVSUk9SX01BUCIsIkVSUk9SX0ZBQ1RPUlkiLCJyZXF1ZXN0R2V0VG9rZW4iLCJoZWFkZXJzIiwiZ2V0SGVhZGVycyIsImJvZHkiLCJnZXRCb2R5Iiwic3Vic2NyaWJlT3B0aW9ucyIsIm1ldGhvZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZSIsImZldGNoIiwiZ2V0RW5kcG9pbnQiLCJqc29uIiwiZXJyIiwiY3JlYXRlIiwiZXJyb3JJbmZvIiwidG9TdHJpbmciLCJlcnJvciIsIm1lc3NhZ2UiLCJyZXF1ZXN0VXBkYXRlVG9rZW4iLCJ1cGRhdGVPcHRpb25zIiwicmVxdWVzdERlbGV0ZVRva2VuIiwidW5zdWJzY3JpYmVPcHRpb25zIiwicHJvamVjdElkIiwiaW5zdGFsbGF0aW9ucyIsImF1dGhUb2tlbiIsImdldFRva2VuIiwiSGVhZGVycyIsIkFjY2VwdCIsImFwaUtleSIsIndlYiIsImFwcGxpY2F0aW9uUHViS2V5IiwiVE9LRU5fRVhQSVJBVElPTl9NUyIsImdldFRva2VuSW50ZXJuYWwiLCJtZXNzYWdpbmciLCJwdXNoU3Vic2NyaXB0aW9uIiwiZ2V0UHVzaFN1YnNjcmlwdGlvbiIsInN3UmVnaXN0cmF0aW9uIiwic2NvcGUiLCJnZXROZXdUb2tlbiIsImlzVG9rZW5WYWxpZCIsImUiLCJjb25zb2xlIiwid2FybiIsInVwZGF0ZVRva2VuIiwiZGVsZXRlVG9rZW5JbnRlcm5hbCIsInB1c2hNYW5hZ2VyIiwiZ2V0U3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJ1cGRhdGVkVG9rZW4iLCJ1cGRhdGVkVG9rZW5EZXRhaWxzIiwiT2JqZWN0IiwiYXNzaWduIiwic3Vic2NyaXB0aW9uIiwic3Vic2NyaWJlIiwidXNlclZpc2libGVPbmx5IiwiYXBwbGljYXRpb25TZXJ2ZXJLZXkiLCJkYk9wdGlvbnMiLCJjdXJyZW50T3B0aW9ucyIsImlzVmFwaWRLZXlFcXVhbCIsImlzRW5kcG9pbnRFcXVhbCIsImlzQXV0aEVxdWFsIiwiaXNQMjU2ZGhFcXVhbCIsImV4dGVybmFsaXplUGF5bG9hZCIsImludGVybmFsUGF5bG9hZCIsInBheWxvYWQiLCJmcm9tIiwiY29sbGFwc2VLZXkiLCJjb2xsYXBzZV9rZXkiLCJtZXNzYWdlSWQiLCJmY21NZXNzYWdlSWQiLCJwcm9wYWdhdGVOb3RpZmljYXRpb25QYXlsb2FkIiwicHJvcGFnYXRlRGF0YVBheWxvYWQiLCJwcm9wYWdhdGVGY21PcHRpb25zIiwibWVzc2FnZVBheWxvYWRJbnRlcm5hbCIsIm5vdGlmaWNhdGlvbiIsInRpdGxlIiwiaW1hZ2UiLCJpY29uIiwiZGF0YSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiZmNtT3B0aW9ucyIsImNsaWNrX2FjdGlvbiIsImxpbmsiLCJhbmFseXRpY3NMYWJlbCIsImFuYWx5dGljc19sYWJlbCIsImlzQ29uc29sZU1lc3NhZ2UiLCJfbWVyZ2VTdHJpbmdzIiwiczEiLCJzMiIsInJlc3VsdEFycmF5IiwicHVzaCIsImNoYXJBdCIsImpvaW4iLCJleHRyYWN0QXBwQ29uZmlnIiwiYXBwIiwib3B0aW9ucyIsImdldE1pc3NpbmdWYWx1ZUVycm9yIiwiY29uZmlnS2V5cyIsImtleU5hbWUiLCJhcHBOYW1lIiwibWVzc2FnaW5nU2VuZGVySWQiLCJ2YWx1ZU5hbWUiLCJNZXNzYWdpbmdTZXJ2aWNlIiwiX2RlbGV0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY29uc3RydWN0b3IiLCJhbmFseXRpY3NQcm92aWRlciIsImRlbGl2ZXJ5TWV0cmljc0V4cG9ydGVkVG9CaWdRdWVyeUVuYWJsZWQiLCJvbkJhY2tncm91bmRNZXNzYWdlSGFuZGxlciIsIm9uTWVzc2FnZUhhbmRsZXIiLCJsb2dFdmVudHMiLCJpc0xvZ1NlcnZpY2VTdGFydGVkIiwicmVnaXN0ZXJEZWZhdWx0U3ciLCJuYXZpZ2F0b3IiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJ1cGRhdGUiLCJjYXRjaCIsImJyb3dzZXJFcnJvck1lc3NhZ2UiLCJ1cGRhdGVTd1JlZyIsIlNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24iLCJ1cGRhdGVWYXBpZEtleSIsImdldFRva2VuJDEiLCJOb3RpZmljYXRpb24iLCJwZXJtaXNzaW9uIiwicmVxdWVzdFBlcm1pc3Npb24iLCJzZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uIiwibG9nVG9TY2lvbiIsIm1lc3NhZ2VUeXBlIiwiZXZlbnRUeXBlIiwiZ2V0RXZlbnRUeXBlIiwiYW5hbHl0aWNzIiwibG9nRXZlbnQiLCJtZXNzYWdlX2lkIiwibWVzc2FnZV9uYW1lIiwibWVzc2FnZV90aW1lIiwibWVzc2FnZV9kZXZpY2VfdGltZSIsIk1hdGgiLCJmbG9vciIsIk5PVElGSUNBVElPTl9DTElDS0VEIiwiUFVTSF9SRUNFSVZFRCIsIkVycm9yIiwibWVzc2FnZUV2ZW50TGlzdGVuZXIiLCJldmVudCIsImlzRmlyZWJhc2VNZXNzYWdpbmciLCJuZXh0IiwiZGF0YVBheWxvYWQiLCJ2ZXJzaW9uIiwiV2luZG93TWVzc2FnaW5nRmFjdG9yeSIsImNvbnRhaW5lciIsImdldFByb3ZpZGVyIiwiZ2V0SW1tZWRpYXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIldpbmRvd01lc3NhZ2luZ0ludGVybmFsRmFjdG9yeSIsIm1lc3NhZ2luZ0ludGVybmFsIiwicmVnaXN0ZXJNZXNzYWdpbmdJbldpbmRvdyIsImlzV2luZG93U3VwcG9ydGVkIiwid2luZG93IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJQdXNoU3Vic2NyaXB0aW9uIiwiZGVsZXRlVG9rZW4kMSIsIm9uTWVzc2FnZSQxIiwibmV4dE9yT2JzZXJ2ZXIiLCJnZXRNZXNzYWdpbmdJbldpbmRvdyIsInRoZW4iLCJpc1N1cHBvcnRlZCIsIl8iLCJkZWxldGVUb2tlbiIsIm9uTWVzc2FnZSIsImdldE1lc3NhZ2luZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/messaging/dist/esm/index.esm2017.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@firebase/messaging/node_modules/idb/build/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: function() { return /* binding */ deleteDB; },\n/* harmony export */   openDB: function() { return /* binding */ openDB; },\n/* harmony export */   unwrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u; },\n/* harmony export */   wrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w; }\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/wrap-idb-value.js\");\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */ function openDB(name, version) {\n    let { blocked, upgrade, blocking, terminated } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener(\"upgradeneeded\", (event)=>{\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));\n        });\n    }\n    if (blocked) request.addEventListener(\"blocked\", ()=>blocked());\n    openPromise.then((db)=>{\n        if (terminated) db.addEventListener(\"close\", ()=>terminated());\n        if (blocking) db.addEventListener(\"versionchange\", ()=>blocking());\n    }).catch(()=>{});\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */ function deleteDB(name) {\n    let { blocked } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) request.addEventListener(\"blocked\", ()=>blocked());\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(()=>undefined);\n}\nconst readMethods = [\n    \"get\",\n    \"getKey\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"count\"\n];\nconst writeMethods = [\n    \"put\",\n    \"add\",\n    \"delete\",\n    \"clear\"\n];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n        return;\n    }\n    if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, \"\");\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function(storeName) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps)=>({\n        ...oldTraps,\n        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUU7QUFDTjtBQUU3RDs7Ozs7O0NBTUMsR0FDRCxTQUFTTSxPQUFPQyxJQUFJLEVBQUVDLE9BQU87UUFBRSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQUUsR0FBMUMsaUVBQTZDLENBQUM7SUFDekUsTUFBTUMsVUFBVUMsVUFBVUMsSUFBSSxDQUFDUixNQUFNQztJQUNyQyxNQUFNUSxjQUFjZixxREFBSUEsQ0FBQ1k7SUFDekIsSUFBSUgsU0FBUztRQUNURyxRQUFRSSxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQ0M7WUFDdkNSLFFBQVFULHFEQUFJQSxDQUFDWSxRQUFRTSxNQUFNLEdBQUdELE1BQU1FLFVBQVUsRUFBRUYsTUFBTUcsVUFBVSxFQUFFcEIscURBQUlBLENBQUNZLFFBQVFTLFdBQVc7UUFDOUY7SUFDSjtJQUNBLElBQUliLFNBQ0FJLFFBQVFJLGdCQUFnQixDQUFDLFdBQVcsSUFBTVI7SUFDOUNPLFlBQ0tPLElBQUksQ0FBQyxDQUFDQztRQUNQLElBQUlaLFlBQ0FZLEdBQUdQLGdCQUFnQixDQUFDLFNBQVMsSUFBTUw7UUFDdkMsSUFBSUQsVUFDQWEsR0FBR1AsZ0JBQWdCLENBQUMsaUJBQWlCLElBQU1OO0lBQ25ELEdBQ0tjLEtBQUssQ0FBQyxLQUFRO0lBQ25CLE9BQU9UO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU1UsU0FBU25CLElBQUk7UUFBRSxFQUFFRSxPQUFPLEVBQUUsR0FBWCxpRUFBYyxDQUFDO0lBQ25DLE1BQU1JLFVBQVVDLFVBQVVhLGNBQWMsQ0FBQ3BCO0lBQ3pDLElBQUlFLFNBQ0FJLFFBQVFJLGdCQUFnQixDQUFDLFdBQVcsSUFBTVI7SUFDOUMsT0FBT1IscURBQUlBLENBQUNZLFNBQVNVLElBQUksQ0FBQyxJQUFNSztBQUNwQztBQUVBLE1BQU1DLGNBQWM7SUFBQztJQUFPO0lBQVU7SUFBVTtJQUFjO0NBQVE7QUFDdEUsTUFBTUMsZUFBZTtJQUFDO0lBQU87SUFBTztJQUFVO0NBQVE7QUFDdEQsTUFBTUMsZ0JBQWdCLElBQUlDO0FBQzFCLFNBQVNDLFVBQVVDLE1BQU0sRUFBRUMsSUFBSTtJQUMzQixJQUFJLENBQUVELENBQUFBLGtCQUFrQkUsZUFDcEIsQ0FBRUQsQ0FBQUEsUUFBUUQsTUFBSyxLQUNmLE9BQU9DLFNBQVMsUUFBTyxHQUFJO1FBQzNCO0lBQ0o7SUFDQSxJQUFJSixjQUFjTSxHQUFHLENBQUNGLE9BQ2xCLE9BQU9KLGNBQWNNLEdBQUcsQ0FBQ0Y7SUFDN0IsTUFBTUcsaUJBQWlCSCxLQUFLSSxPQUFPLENBQUMsY0FBYztJQUNsRCxNQUFNQyxXQUFXTCxTQUFTRztJQUMxQixNQUFNRyxVQUFVWCxhQUFhWSxRQUFRLENBQUNKO0lBQ3RDLElBQ0EsNEVBQTRFO0lBQzVFLENBQUVBLENBQUFBLGtCQUFrQixDQUFDRSxXQUFXRyxXQUFXQyxjQUFhLEVBQUdDLFNBQVMsS0FDaEUsQ0FBRUosQ0FBQUEsV0FBV1osWUFBWWEsUUFBUSxDQUFDSixlQUFjLEdBQUk7UUFDcEQ7SUFDSjtJQUNBLE1BQU1RLFNBQVMsZUFBZ0JDLFNBQVM7UUFBRTtZQUFHQyxLQUFILDJCQUFPOztRQUM3Qyx3RUFBd0U7UUFDeEUsTUFBTUMsS0FBSyxJQUFJLENBQUMzQixXQUFXLENBQUN5QixXQUFXTixVQUFVLGNBQWM7UUFDL0QsSUFBSVAsU0FBU2UsR0FBR0MsS0FBSztRQUNyQixJQUFJVixVQUNBTixTQUFTQSxPQUFPaUIsS0FBSyxDQUFDSCxLQUFLSSxLQUFLO1FBQ3BDLDZCQUE2QjtRQUM3Qiw2REFBNkQ7UUFDN0QsdUNBQXVDO1FBQ3ZDLDhCQUE4QjtRQUM5QixzREFBc0Q7UUFDdEQsT0FBTyxDQUFDLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztZQUN0QnBCLE1BQU0sQ0FBQ0ksZUFBZSxJQUFJVTtZQUMxQlAsV0FBV1EsR0FBR00sSUFBSTtTQUNyQixFQUFFLENBQUMsRUFBRTtJQUNWO0lBQ0F4QixjQUFjeUIsR0FBRyxDQUFDckIsTUFBTVc7SUFDeEIsT0FBT0E7QUFDWDtBQUNBM0MscURBQVlBLENBQUMsQ0FBQ3NELFdBQWM7UUFDeEIsR0FBR0EsUUFBUTtRQUNYcEIsS0FBSyxDQUFDSCxRQUFRQyxNQUFNdUIsV0FBYXpCLFVBQVVDLFFBQVFDLFNBQVNzQixTQUFTcEIsR0FBRyxDQUFDSCxRQUFRQyxNQUFNdUI7UUFDdkZDLEtBQUssQ0FBQ3pCLFFBQVFDLE9BQVMsQ0FBQyxDQUFDRixVQUFVQyxRQUFRQyxTQUFTc0IsU0FBU0UsR0FBRyxDQUFDekIsUUFBUUM7SUFDN0U7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvbm9kZV9tb2R1bGVzL2lkYi9idWlsZC9pbmRleC5qcz9iMmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHcgYXMgd3JhcCwgciBhcyByZXBsYWNlVHJhcHMgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcbmV4cG9ydCB7IHUgYXMgdW53cmFwLCB3IGFzIHdyYXAgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChibG9ja2VkKVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoKSA9PiBibG9ja2VkKCkpO1xuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcigndmVyc2lvbmNoYW5nZScsICgpID0+IGJsb2NraW5nKCkpO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIHJldHVybiBvcGVuUHJvbWlzZTtcbn1cbi8qKlxuICogRGVsZXRlIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURCKG5hbWUsIHsgYmxvY2tlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgIGlmIChibG9ja2VkKVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoKSA9PiBibG9ja2VkKCkpO1xuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiB9O1xuIl0sIm5hbWVzIjpbInciLCJ3cmFwIiwiciIsInJlcGxhY2VUcmFwcyIsInUiLCJ1bndyYXAiLCJvcGVuREIiLCJuYW1lIiwidmVyc2lvbiIsImJsb2NrZWQiLCJ1cGdyYWRlIiwiYmxvY2tpbmciLCJ0ZXJtaW5hdGVkIiwicmVxdWVzdCIsImluZGV4ZWREQiIsIm9wZW4iLCJvcGVuUHJvbWlzZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlc3VsdCIsIm9sZFZlcnNpb24iLCJuZXdWZXJzaW9uIiwidHJhbnNhY3Rpb24iLCJ0aGVuIiwiZGIiLCJjYXRjaCIsImRlbGV0ZURCIiwiZGVsZXRlRGF0YWJhc2UiLCJ1bmRlZmluZWQiLCJyZWFkTWV0aG9kcyIsIndyaXRlTWV0aG9kcyIsImNhY2hlZE1ldGhvZHMiLCJNYXAiLCJnZXRNZXRob2QiLCJ0YXJnZXQiLCJwcm9wIiwiSURCRGF0YWJhc2UiLCJnZXQiLCJ0YXJnZXRGdW5jTmFtZSIsInJlcGxhY2UiLCJ1c2VJbmRleCIsImlzV3JpdGUiLCJpbmNsdWRlcyIsIklEQkluZGV4IiwiSURCT2JqZWN0U3RvcmUiLCJwcm90b3R5cGUiLCJtZXRob2QiLCJzdG9yZU5hbWUiLCJhcmdzIiwidHgiLCJzdG9yZSIsImluZGV4Iiwic2hpZnQiLCJQcm9taXNlIiwiYWxsIiwiZG9uZSIsInNldCIsIm9sZFRyYXBzIiwicmVjZWl2ZXIiLCJoYXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/wrap-idb-value.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@firebase/messaging/node_modules/idb/build/wrap-idb-value.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ reverseTransformCache; },\n/* harmony export */   i: function() { return /* binding */ instanceOfAny; },\n/* harmony export */   r: function() { return /* binding */ replaceTraps; },\n/* harmony export */   u: function() { return /* binding */ unwrap; },\n/* harmony export */   w: function() { return /* binding */ wrap; }\n/* harmony export */ });\nconst instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return idbProxyableTypes || (idbProxyableTypes = [\n        IDBDatabase,\n        IDBObjectStore,\n        IDBIndex,\n        IDBCursor,\n        IDBTransaction\n    ]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\n        IDBCursor.prototype.advance,\n        IDBCursor.prototype.continue,\n        IDBCursor.prototype.continuePrimaryKey\n    ]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            request.removeEventListener(\"success\", success);\n            request.removeEventListener(\"error\", error);\n        };\n        const success = ()=>{\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = ()=>{\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener(\"success\", success);\n        request.addEventListener(\"error\", error);\n    });\n    promise.then((value)=>{\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n    }).catch(()=>{});\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx)) return;\n    const done = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            tx.removeEventListener(\"complete\", complete);\n            tx.removeEventListener(\"error\", error);\n            tx.removeEventListener(\"abort\", error);\n        };\n        const complete = ()=>{\n            resolve();\n            unlisten();\n        };\n        const error = ()=>{\n            reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n            unlisten();\n        };\n        tx.addEventListener(\"complete\", complete);\n        tx.addEventListener(\"error\", error);\n        tx.addEventListener(\"abort\", error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get (target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === \"done\") return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === \"objectStoreNames\") {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === \"store\") {\n                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set (target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has (target, prop) {\n        if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n            return true;\n        }\n        return prop in target;\n    }\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction && !(\"objectStoreNames\" in IDBTransaction.prototype)) {\n        return function(storeNames) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [\n                storeNames\n            ]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === \"function\") return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest) return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value)) return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value)=>reverseTransformCache.get(value);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvd3JhcC1pZGItdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQUFNQSxnQkFBZ0IsQ0FBQ0MsUUFBUUMsZUFBaUJBLGFBQWFDLElBQUksQ0FBQyxDQUFDQyxJQUFNSCxrQkFBa0JHO0FBRTNGLElBQUlDO0FBQ0osSUFBSUM7QUFDSixxRUFBcUU7QUFDckUsU0FBU0M7SUFDTCxPQUFRRixxQkFDSEEsQ0FBQUEsb0JBQW9CO1FBQ2pCRztRQUNBQztRQUNBQztRQUNBQztRQUNBQztLQUNIO0FBQ1Q7QUFDQSxxRUFBcUU7QUFDckUsU0FBU0M7SUFDTCxPQUFRUCx3QkFDSEEsQ0FBQUEsdUJBQXVCO1FBQ3BCSyxVQUFVRyxTQUFTLENBQUNDLE9BQU87UUFDM0JKLFVBQVVHLFNBQVMsQ0FBQ0UsUUFBUTtRQUM1QkwsVUFBVUcsU0FBUyxDQUFDRyxrQkFBa0I7S0FDekM7QUFDVDtBQUNBLE1BQU1DLG1CQUFtQixJQUFJQztBQUM3QixNQUFNQyxxQkFBcUIsSUFBSUQ7QUFDL0IsTUFBTUUsMkJBQTJCLElBQUlGO0FBQ3JDLE1BQU1HLGlCQUFpQixJQUFJSDtBQUMzQixNQUFNSSx3QkFBd0IsSUFBSUo7QUFDbEMsU0FBU0ssaUJBQWlCQyxPQUFPO0lBQzdCLE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNsQyxNQUFNQyxXQUFXO1lBQ2JMLFFBQVFNLG1CQUFtQixDQUFDLFdBQVdDO1lBQ3ZDUCxRQUFRTSxtQkFBbUIsQ0FBQyxTQUFTRTtRQUN6QztRQUNBLE1BQU1ELFVBQVU7WUFDWkosUUFBUU0sS0FBS1QsUUFBUVUsTUFBTTtZQUMzQkw7UUFDSjtRQUNBLE1BQU1HLFFBQVE7WUFDVkosT0FBT0osUUFBUVEsS0FBSztZQUNwQkg7UUFDSjtRQUNBTCxRQUFRVyxnQkFBZ0IsQ0FBQyxXQUFXSjtRQUNw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Qi9DLHNCQUFzQmdCLEdBQUcsQ0FBQytCLFVBQVVoQztJQUN4QztJQUNBLE9BQU9nQztBQUNYO0FBQ0EsTUFBTVAsU0FBUyxDQUFDekIsUUFBVWYsc0JBQXNCeUIsR0FBRyxDQUFDVjtBQUVpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzP2ZmZDAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IGN1cnNvclJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gU2luY2UgY3Vyc29yaW5nIHJldXNlcyB0aGUgSURCUmVxdWVzdCAoKnNpZ2gqKSwgd2UgY2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAvLyAoc2VlIHdyYXBGdW5jdGlvbikuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdE1hcC5zZXQodmFsdWUsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb2JqZWN0U3RvcmVOYW1lcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm9iamVjdFN0b3JlTmFtZXMgfHwgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0eC5zdG9yZSByZXR1cm4gdGhlIG9ubHkgc3RvcmUgaW4gdGhlIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG1hbnkuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogcmVjZWl2ZXIub2JqZWN0U3RvcmUocmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB0cmFuc2Zvcm0gd2hhdGV2ZXIgd2UgZ2V0IGJhY2suXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgKHByb3AgPT09ICdkb25lJyB8fCBwcm9wID09PSAnc3RvcmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVwbGFjZVRyYXBzKGNhbGxiYWNrKSB7XG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxuICAgIC8vIG9ubHkgY3JlYXRlIG9uZSBuZXcgZnVuYyBwZXIgZnVuYy5cbiAgICAvLyBFZGdlIGRvZXNuJ3Qgc3VwcG9ydCBvYmplY3RTdG9yZU5hbWVzIChib29vKSwgc28gd2UgcG9seWZpbGwgaXQgaGVyZS5cbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXG4gICAgICAgICEoJ29iamVjdFN0b3JlTmFtZXMnIGluIElEQlRyYW5zYWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZU5hbWVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLnNldCh0eCwgc3RvcmVOYW1lcy5zb3J0ID8gc3RvcmVOYW1lcy5zb3J0KCkgOiBbc3RvcmVOYW1lc10pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDdXJzb3IgbWV0aG9kcyBhcmUgc3BlY2lhbCwgYXMgdGhlIGJlaGF2aW91ciBpcyBhIGxpdHRsZSBtb3JlIGRpZmZlcmVudCB0byBzdGFuZGFyZCBJREIuIEluXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcbiAgICAvLyBjdXJzb3IuIEl0J3Mga2luZGEgbGlrZSBhIHByb21pc2UgdGhhdCBjYW4gcmVzb2x2ZSB3aXRoIG1hbnkgdmFsdWVzLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIHdpdGggcmVhbCBwcm9taXNlcywgc28gZWFjaCBhZHZhbmNlIG1ldGhvZHMgcmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgY3Vyc29yIG9iamVjdCwgb3JcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgaWYgKGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkuaW5jbHVkZXMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICAgICAgZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbmV4cG9ydCB7IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBhcyBhLCBpbnN0YW5jZU9mQW55IGFzIGksIHJlcGxhY2VUcmFwcyBhcyByLCB1bndyYXAgYXMgdSwgd3JhcCBhcyB3IH07XG4iXSwibmFtZXMiOlsiaW5zdGFuY2VPZkFueSIsIm9iamVjdCIsImNvbnN0cnVjdG9ycyIsInNvbWUiLCJjIiwiaWRiUHJveHlhYmxlVHlwZXMiLCJjdXJzb3JBZHZhbmNlTWV0aG9kcyIsImdldElkYlByb3h5YWJsZVR5cGVzIiwiSURCRGF0YWJhc2UiLCJJREJPYmplY3RTdG9yZSIsIklEQkluZGV4IiwiSURCQ3Vyc29yIiwiSURCVHJhbnNhY3Rpb24iLCJnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcyIsInByb3RvdHlwZSIsImFkdmFuY2UiLCJjb250aW51ZSIsImNvbnRpbnVlUHJpbWFyeUtleSIsImN1cnNvclJlcXVlc3RNYXAiLCJXZWFrTWFwIiwidHJhbnNhY3Rpb25Eb25lTWFwIiwidHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwIiwidHJhbnNmb3JtQ2FjaGUiLCJyZXZlcnNlVHJhbnNmb3JtQ2FjaGUiLCJwcm9taXNpZnlSZXF1ZXN0IiwicmVxdWVzdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInVubGlzdGVuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN1Y2Nlc3MiLCJlcnJvciIsIndyYXAiLCJyZXN1bHQiLCJhZGRFdmVudExpc3RlbmVyIiwidGhlbiIsInZhbHVlIiwic2V0IiwiY2F0Y2giLCJjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24iLCJ0eCIsImhhcyIsImRvbmUiLCJjb21wbGV0ZSIsIkRPTUV4Y2VwdGlvbiIsImlkYlByb3h5VHJhcHMiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJvYmplY3RTdG9yZU5hbWVzIiwidW5kZWZpbmVkIiwib2JqZWN0U3RvcmUiLCJyZXBsYWNlVHJhcHMiLCJjYWxsYmFjayIsIndyYXBGdW5jdGlvbiIsImZ1bmMiLCJ0cmFuc2FjdGlvbiIsInN0b3JlTmFtZXMiLCJhcmdzIiwiY2FsbCIsInVud3JhcCIsInNvcnQiLCJpbmNsdWRlcyIsImFwcGx5IiwidHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSIsIlByb3h5IiwiSURCUmVxdWVzdCIsIm5ld1ZhbHVlIiwiYSIsImkiLCJyIiwidSIsInciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/messaging/node_modules/idb/build/wrap-idb-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/firebase/messaging/dist/esm/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/firebase/messaging/dist/esm/index.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteToken: function() { return /* reexport safe */ _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__.deleteToken; },\n/* harmony export */   getMessaging: function() { return /* reexport safe */ _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__.getMessaging; },\n/* harmony export */   getToken: function() { return /* reexport safe */ _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__.getToken; },\n/* harmony export */   isSupported: function() { return /* reexport safe */ _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__.isSupported; },\n/* harmony export */   onMessage: function() { return /* reexport safe */ _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__.onMessage; }\n/* harmony export */ });\n/* harmony import */ var _firebase_messaging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/messaging */ \"(app-pages-browser)/./node_modules/@firebase/messaging/dist/esm/index.esm2017.js\");\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvQyxDQUNwQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9pbmRleC5lc20uanM/MGE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvbWVzc2FnaW5nJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/firebase/messaging/dist/esm/index.esm.js\n"));

/***/ })

}]);